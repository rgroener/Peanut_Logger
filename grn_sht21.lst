   1               		.file	"grn_sht21.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	sht21_init
  12               	sht21_init:
  13               	.LFB7:
  14               		.file 1 "grn_sht21.c"
   1:grn_sht21.c   **** /*	Library File
   2:grn_sht21.c   ****  * 
   3:grn_sht21.c   ****  * 	Sensirion SHT21 Sensor (Temperature / Humidity)
   4:grn_sht21.c   ****  *
   5:grn_sht21.c   ****  * 	grn; Apr 15
   6:grn_sht21.c   ****  */
   7:grn_sht21.c   ****  #define F_CPU 8000000UL                 // set the CPU clock
   8:grn_sht21.c   **** #include <stdio.h>
   9:grn_sht21.c   **** #include <avr/io.h>
  10:grn_sht21.c   **** #include <util/delay.h>
  11:grn_sht21.c   **** #include "grn_TWI.h"
  12:grn_sht21.c   **** #include "grn_sht21.h"
  13:grn_sht21.c   **** 
  14:grn_sht21.c   **** #define SHT21_W 0x80				//SHT21 Adresse und schreiben 	0x80
  15:grn_sht21.c   **** #define SHT21_R 0x81				//SHT21 Adresse und lesen		0x81
  16:grn_sht21.c   **** #define SHT21_TEMP_HOLDMASTER 0xE3		//Tempreature hold master = on =>0b11100011
  17:grn_sht21.c   **** #define SHT21_HUM_HOLDMASTER 0xF3		//Humidity hold master = on => 0b11100101
  18:grn_sht21.c   **** #define SHT21_SOFTRESET 0xFE				//Softreset
  19:grn_sht21.c   **** #define POLYNOMINAL 0x131				//P(x) = x^8+x^5+x^4+1 = 0b100110001
  20:grn_sht21.c   **** #define T_HOLD 	0
  21:grn_sht21.c   **** #define RH_HOLD 	1
  22:grn_sht21.c   **** 
  23:grn_sht21.c   **** typedef float ft;						//Float VAriable zur Umrechnung vor Rueckgabe
  24:grn_sht21.c   **** uint8_t sht21_init(void)
  25:grn_sht21.c   **** {
  15               		.loc 1 25 1 view -0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  26:grn_sht21.c   **** 	/*	
  27:grn_sht21.c   **** 	 * Softreset Sensor
  28:grn_sht21.c   **** 	 */
  29:grn_sht21.c   **** 	TWIStart();
  21               		.loc 1 29 2 view .LVU1
  22 0000 0E94 0000 		call TWIStart
  23               	.LVL0:
  30:grn_sht21.c   **** 	if(TWIGetStatus() != 0x08)return 1; 
  24               		.loc 1 30 2 view .LVU2
  25               		.loc 1 30 5 is_stmt 0 view .LVU3
  26 0004 0E94 0000 		call TWIGetStatus
  27               	.LVL1:
  28               		.loc 1 30 4 view .LVU4
  29 0008 8830      		cpi r24,lo8(8)
  30 000a 01F0      		breq .L7
  31               		.loc 1 30 35 view .LVU5
  32 000c 81E0      		ldi r24,lo8(1)
  33 000e 0895      		ret
  34               	.L7:
  31:grn_sht21.c   **** 	TWIWrite(SHT21_W);
  35               		.loc 1 31 2 is_stmt 1 view .LVU6
  36 0010 80E8      		ldi r24,lo8(-128)
  37 0012 0E94 0000 		call TWIWrite
  38               	.LVL2:
  32:grn_sht21.c   **** 	if(TWIGetStatus() != 0x18)return 2;
  39               		.loc 1 32 2 view .LVU7
  40               		.loc 1 32 5 is_stmt 0 view .LVU8
  41 0016 0E94 0000 		call TWIGetStatus
  42               	.LVL3:
  43               		.loc 1 32 4 view .LVU9
  44 001a 8831      		cpi r24,lo8(24)
  45 001c 01F0      		breq .L8
  46               		.loc 1 32 35 view .LVU10
  47 001e 82E0      		ldi r24,lo8(2)
  48 0020 0895      		ret
  49               	.L8:
  33:grn_sht21.c   **** 	TWIWrite(SHT21_SOFTRESET);
  50               		.loc 1 33 2 is_stmt 1 view .LVU11
  51 0022 8EEF      		ldi r24,lo8(-2)
  52 0024 0E94 0000 		call TWIWrite
  53               	.LVL4:
  34:grn_sht21.c   **** 	if(TWIGetStatus() != 0x28)return 3;
  54               		.loc 1 34 2 view .LVU12
  55               		.loc 1 34 5 is_stmt 0 view .LVU13
  56 0028 0E94 0000 		call TWIGetStatus
  57               	.LVL5:
  58               		.loc 1 34 4 view .LVU14
  59 002c 8832      		cpi r24,lo8(40)
  60 002e 01F4      		brne .L5
  35:grn_sht21.c   **** 	TWIStop();
  61               		.loc 1 35 2 is_stmt 1 view .LVU15
  62 0030 0E94 0000 		call TWIStop
  63               	.LVL6:
  36:grn_sht21.c   **** 	_delay_ms(15);	//Startuptime after Reset <15ms (Datasheet)
  64               		.loc 1 36 2 view .LVU16
  65               	.LBB12:
  66               	.LBI12:
  67               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
  68               		.loc 2 166 1 view .LVU17
  69               	.LBB13:
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
  70               		.loc 2 168 2 view .LVU18
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/avr/include/util/delay.h **** 
 189:/usr/avr/include/util/delay.h **** #else
 190:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
  71               		.loc 2 190 2 view .LVU19
 191:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
  72               		.loc 2 191 2 view .LVU20
 192:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
  73               		.loc 2 192 2 view .LVU21
 193:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
  74               		.loc 2 194 7 view .LVU22
 195:/usr/avr/include/util/delay.h **** 	{
 196:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/avr/include/util/delay.h **** 		{
 200:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/avr/include/util/delay.h **** 		}
 204:/usr/avr/include/util/delay.h **** 		return;
 205:/usr/avr/include/util/delay.h **** 	}
 206:/usr/avr/include/util/delay.h **** 	else
 207:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
  75               		.loc 2 207 3 view .LVU23
 208:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
  76               		.loc 2 208 2 view .LVU24
  77               	.LBB14:
  78               	.LBI14:
  79               		.file 3 "/usr/avr/include/util/delay_basic.h"
   1:/usr/avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:/usr/avr/include/util/delay_basic.h ****    All rights reserved.
   4:/usr/avr/include/util/delay_basic.h **** 
   5:/usr/avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/avr/include/util/delay_basic.h **** 
   8:/usr/avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/avr/include/util/delay_basic.h **** 
  11:/usr/avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:/usr/avr/include/util/delay_basic.h ****      distribution.
  15:/usr/avr/include/util/delay_basic.h **** 
  16:/usr/avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:/usr/avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:/usr/avr/include/util/delay_basic.h **** 
  20:/usr/avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/avr/include/util/delay_basic.h **** 
  32:/usr/avr/include/util/delay_basic.h **** /* $Id: delay_basic.h 2453 2014-10-19 08:18:11Z saaadhu $ */
  33:/usr/avr/include/util/delay_basic.h **** 
  34:/usr/avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:/usr/avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:/usr/avr/include/util/delay_basic.h **** 
  37:/usr/avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:/usr/avr/include/util/delay_basic.h **** 
  39:/usr/avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  40:/usr/avr/include/util/delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:/usr/avr/include/util/delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:/usr/avr/include/util/delay_basic.h **** #endif
  43:/usr/avr/include/util/delay_basic.h **** 
  44:/usr/avr/include/util/delay_basic.h **** /** \file */
  45:/usr/avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:/usr/avr/include/util/delay_basic.h ****     \code
  47:/usr/avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  48:/usr/avr/include/util/delay_basic.h ****     \endcode
  49:/usr/avr/include/util/delay_basic.h **** 
  50:/usr/avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  51:/usr/avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:/usr/avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:/usr/avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:/usr/avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:/usr/avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:/usr/avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  57:/usr/avr/include/util/delay_basic.h **** 
  58:/usr/avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:/usr/avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:/usr/avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  61:/usr/avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  62:/usr/avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:/usr/avr/include/util/delay_basic.h ****     to the overall delay time.
  64:/usr/avr/include/util/delay_basic.h **** 
  65:/usr/avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:/usr/avr/include/util/delay_basic.h **** 
  67:/usr/avr/include/util/delay_basic.h **** */
  68:/usr/avr/include/util/delay_basic.h **** 
  69:/usr/avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:/usr/avr/include/util/delay_basic.h **** 
  71:/usr/avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:/usr/avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:/usr/avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:/usr/avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:/usr/avr/include/util/delay_basic.h ****     register.
  76:/usr/avr/include/util/delay_basic.h **** 
  77:/usr/avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:/usr/avr/include/util/delay_basic.h ****     can be achieved.
  79:/usr/avr/include/util/delay_basic.h **** */
  80:/usr/avr/include/util/delay_basic.h **** void
  81:/usr/avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:/usr/avr/include/util/delay_basic.h **** {
  83:/usr/avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:/usr/avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:/usr/avr/include/util/delay_basic.h **** 		"brne 1b"
  86:/usr/avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:/usr/avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:/usr/avr/include/util/delay_basic.h **** 	);
  89:/usr/avr/include/util/delay_basic.h **** }
  90:/usr/avr/include/util/delay_basic.h **** 
  91:/usr/avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:/usr/avr/include/util/delay_basic.h **** 
  93:/usr/avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:/usr/avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:/usr/avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:/usr/avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:/usr/avr/include/util/delay_basic.h ****     counter register pair.
  98:/usr/avr/include/util/delay_basic.h **** 
  99:/usr/avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:/usr/avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:/usr/avr/include/util/delay_basic.h ****  */
 102:/usr/avr/include/util/delay_basic.h **** void
 103:/usr/avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
  80               		.loc 3 103 1 view .LVU25
  81               	.LBB15:
 104:/usr/avr/include/util/delay_basic.h **** {
 105:/usr/avr/include/util/delay_basic.h **** 	__asm__ volatile (
  82               		.loc 3 105 2 view .LVU26
  83 0034 80E3      		ldi r24,lo8(48)
  84 0036 95E7      		ldi r25,lo8(117)
  85               	/* #APP */
  86               	 ;  105 "/usr/avr/include/util/delay_basic.h" 1
  87 0038 0197      		1: sbiw r24,1
  88 003a 01F4      		brne 1b
  89               	 ;  0 "" 2
  90               	.LVL7:
  91               		.loc 3 105 2 is_stmt 0 view .LVU27
  92               	/* #NOAPP */
  93               	.LBE15:
  94               	.LBE14:
  95               	.LBE13:
  96               	.LBE12:
  37:grn_sht21.c   **** 	return 0;
  97               		.loc 1 37 9 view .LVU28
  98 003c 80E0      		ldi r24,0
  99               	.LBB19:
 100               	.LBB18:
 101               	.LBB17:
 102               	.LBB16:
 106:/usr/avr/include/util/delay_basic.h **** 		"1: sbiw %0,1" "\n\t"
 107:/usr/avr/include/util/delay_basic.h **** 		"brne 1b"
 108:/usr/avr/include/util/delay_basic.h **** 		: "=w" (__count)
 109:/usr/avr/include/util/delay_basic.h **** 		: "0" (__count)
 110:/usr/avr/include/util/delay_basic.h **** 	);
 111:/usr/avr/include/util/delay_basic.h **** }
 103               		.loc 3 111 1 view .LVU29
 104 003e 0895      		ret
 105               	.LVL8:
 106               	.L5:
 107               		.loc 3 111 1 view .LVU30
 108               	.LBE16:
 109               	.LBE17:
 110               	.LBE18:
 111               	.LBE19:
  34:grn_sht21.c   **** 	TWIStop();
 112               		.loc 1 34 35 view .LVU31
 113 0040 83E0      		ldi r24,lo8(3)
 114               	/* epilogue start */
  38:grn_sht21.c   **** }
 115               		.loc 1 38 1 view .LVU32
 116 0042 0895      		ret
 117               		.cfi_endproc
 118               	.LFE7:
 120               	.global	__floatunsisf
 121               	.global	__mulsf3
 122               	.global	__subsf3
 123               	.global	__fixsfsi
 124               	.global	sht21_measure
 126               	sht21_measure:
 127               	.LVL9:
 128               	.LFB8:
  39:grn_sht21.c   **** int16_t sht21_measure(uint8_t measure_mode)
  40:grn_sht21.c   **** {
 129               		.loc 1 40 1 is_stmt 1 view -0
 130               		.cfi_startproc
 131               		.loc 1 40 1 is_stmt 0 view .LVU34
 132 0044 FF92      		push r15
 133               	.LCFI0:
 134               		.cfi_def_cfa_offset 3
 135               		.cfi_offset 15, -2
 136 0046 0F93      		push r16
 137               	.LCFI1:
 138               		.cfi_def_cfa_offset 4
 139               		.cfi_offset 16, -3
 140 0048 1F93      		push r17
 141               	.LCFI2:
 142               		.cfi_def_cfa_offset 5
 143               		.cfi_offset 17, -4
 144 004a CF93      		push r28
 145               	.LCFI3:
 146               		.cfi_def_cfa_offset 6
 147               		.cfi_offset 28, -5
 148 004c DF93      		push r29
 149               	.LCFI4:
 150               		.cfi_def_cfa_offset 7
 151               		.cfi_offset 29, -6
 152 004e 00D0      		rcall .
 153 0050 00D0      		rcall .
 154 0052 0F92      		push __tmp_reg__
 155               	.LCFI5:
 156               		.cfi_def_cfa_offset 12
 157 0054 CDB7      		in r28,__SP_L__
 158 0056 DEB7      		in r29,__SP_H__
 159               	.LCFI6:
 160               		.cfi_def_cfa_register 28
 161               	/* prologue: function */
 162               	/* frame size = 5 */
 163               	/* stack size = 10 */
 164               	.L__stack_usage = 10
 165 0058 8983      		std Y+1,r24
  41:grn_sht21.c   **** 	/*
  42:grn_sht21.c   **** 	 * 	Temperaturmessung / Überprüfung der Checksumme	
  43:grn_sht21.c   **** 	 * 
  44:grn_sht21.c   **** 	 * 	Rückgabewert: 	16 bit Temperaturwert x 100 
  45:grn_sht21.c   **** 	 * 					(letzte 2 Stellen sind Nachkommastellen)
  46:grn_sht21.c   **** 	 * 
  47:grn_sht21.c   **** 	 * For float as return value, you have to change the following line in 
  48:grn_sht21.c   **** 	 * the Makefile and add mat.h library since only a minimalistic sprintf library is included
  49:grn_sht21.c   **** 	 * by default. To add the full float library add/change the following 
  50:grn_sht21.c   **** 	 * line to the Makefile.
  51:grn_sht21.c   **** 	 * 
  52:grn_sht21.c   **** 	 * # Minimalistic printf version
  53:grn_sht21.c   **** 		PRINTF_LIB_MIN = -Wl,-u,vfprintf -lprintf_min
  54:grn_sht21.c   **** 
  55:grn_sht21.c   **** 		# Floating point printf version (requires MATH_LIB = -lm below)
  56:grn_sht21.c   **** 		PRINTF_LIB_FLOAT = -Wl,-u,vfprintf -lprintf_flt
  57:grn_sht21.c   **** 
  58:grn_sht21.c   **** 
  59:grn_sht21.c   **** 		PRINTF_LIB = $(PRINTF_LIB_FLOAT) 
  60:grn_sht21.c   **** 	 * 
  61:grn_sht21.c   **** 	 * 
  62:grn_sht21.c   **** 	 * 	Checksum error: Rückgabewert = 99;
  63:grn_sht21.c   **** 	 */ 
  64:grn_sht21.c   **** 	 
  65:grn_sht21.c   **** 	uint8_t raw[]={0,0,0};
 166               		.loc 1 65 2 is_stmt 1 view .LVU35
 167               	.LVL10:
  66:grn_sht21.c   **** 	uint16_t messwert,i;
 168               		.loc 1 66 2 view .LVU36
  67:grn_sht21.c   **** 	int16_t rueckgabewert;
 169               		.loc 1 67 2 view .LVU37
  68:grn_sht21.c   **** 	uint8_t ret=0;
 170               		.loc 1 68 2 view .LVU38
  69:grn_sht21.c   **** 	
  70:grn_sht21.c   **** 	messwert=0;
 171               		.loc 1 70 2 view .LVU39
  71:grn_sht21.c   **** 	rueckgabewert=0;
 172               		.loc 1 71 2 view .LVU40
  72:grn_sht21.c   **** 	/*
  73:grn_sht21.c   **** 0x00	No errors
  74:grn_sht21.c   **** 0x08	START condition transmitted
  75:grn_sht21.c   **** 0x10	Repeated START condition transmitted
  76:grn_sht21.c   **** 0x18	SLA+W transmitted; ACK received
  77:grn_sht21.c   **** 0x20	SLA+W transmitted; NAK received
  78:grn_sht21.c   **** 0x28	Data byte transmitted; ACK received
  79:grn_sht21.c   **** 0x30	Data byte transmitted; NAK received
  80:grn_sht21.c   **** 0x38	Arbitration lost in SLA; or NAK received
  81:grn_sht21.c   **** 0x40	SLA+R transmitted; ACK received
  82:grn_sht21.c   **** 0x48	SLA+R transmitted; NAK received
  83:grn_sht21.c   **** 0x50	Data received; ACK has been returned
  84:grn_sht21.c   **** 0x58	Data received; NAK has been returned
  85:grn_sht21.c   **** 0xE0	Arbitration lost
  86:grn_sht21.c   **** 0xE1	Arbitration lost in START
  87:grn_sht21.c   **** 0xE2	Arbitration lost in STOP
  88:grn_sht21.c   **** 0xE3	Arbitration lost in read ACK
  89:grn_sht21.c   **** 0xE4	Arbitration lost in read NAK
  90:grn_sht21.c   **** 0xE5	Arbitration lost in write
  91:grn_sht21.c   **** 0xF8	Unknown error
  92:grn_sht21.c   **** 0xFF	Illegal START or STOP condition
  93:grn_sht21.c   **** 	*/
  94:grn_sht21.c   **** 	TWIStart();		
 173               		.loc 1 94 2 view .LVU41
 174 005a 0E94 0000 		call TWIStart
 175               	.LVL11:
  95:grn_sht21.c   **** 	ret=TWIGetStatus();						//start TWI
 176               		.loc 1 95 2 view .LVU42
 177               		.loc 1 95 6 is_stmt 0 view .LVU43
 178 005e 0E94 0000 		call TWIGetStatus
 179               	.LVL12:
 180 0062 8D83      		std Y+5,r24
 181               	.LVL13:
  96:grn_sht21.c   **** 	if(ret != 0x08)return ret; 	//start condition transmitted?
 182               		.loc 1 96 2 is_stmt 1 view .LVU44
 183               		.loc 1 96 24 is_stmt 0 view .LVU45
 184 0064 90E0      		ldi r25,0
 185               		.loc 1 96 4 view .LVU46
 186 0066 8830      		cpi r24,lo8(8)
 187 0068 01F0      		breq .L45
 188               	.LVL14:
 189               	.L9:
 190               	/* epilogue start */
  97:grn_sht21.c   **** 	TWIWrite(SHT21_W);			//send write adress
  98:grn_sht21.c   **** 	if(TWIGetStatus() != 0x18)return 22;	//SLA+W transmitted?
  99:grn_sht21.c   **** 	switch(measure_mode)
 100:grn_sht21.c   **** 	{
 101:grn_sht21.c   **** 		case T_HOLD:	TWIWrite(SHT21_TEMP_HOLDMASTER);break;	//Modus = Temperatur master hold = on
 102:grn_sht21.c   **** 		case RH_HOLD:	TWIWrite(SHT21_HUM_HOLDMASTER);break;	//Modus = Temperatur master hold = on
 103:grn_sht21.c   **** 	}
 104:grn_sht21.c   **** 	if(TWIGetStatus() != 0x28)return 33;	//kontrolle ob erfolgreich sonst Abbruch mit Error Code
 105:grn_sht21.c   **** 	TWIStart();								//restart TWI
 106:grn_sht21.c   **** 	if(TWIGetStatus() != 0x10)return 44; 	//kontrolle ob erfolgreich sonst Abbruch mit Error Code
 107:grn_sht21.c   **** 	TWIWrite(SHT21_R);						//Adresse und lesen
 108:grn_sht21.c   **** 	if(TWIGetStatus() != 0x40)return 55;	//kontrolle ob erfolgreich sonst Abbruch mit Error Code
 109:grn_sht21.c   **** 	
 110:grn_sht21.c   **** 	DDRC &= ~(1<<PC5);					//set SCL as Input
 111:grn_sht21.c   **** 	for(i=0;i<1000;i++)					//wait for timeout or
 112:grn_sht21.c   **** 	{
 113:grn_sht21.c   **** 		if(PINC &= ~(1<<PC5))break;		//wait for end of conversion (Master hold mode)
 114:grn_sht21.c   **** 	}
 115:grn_sht21.c   **** 	DDRC |= (1<<PC5);					//set SCL as Output again
 116:grn_sht21.c   **** 	
 117:grn_sht21.c   **** 	raw[0] = TWIReadACK();				//empfange MSB
 118:grn_sht21.c   **** 	if(TWIGetStatus() != 0x50)return 66;	//kontrolle ob erfolgreich sonst Abbruch mit Error Code
 119:grn_sht21.c   **** 	raw[1] = TWIReadACK();				//empfange LSB / durch NACK wird checksumme nicht empfangen
 120:grn_sht21.c   **** 	if(TWIGetStatus() != 0x50)return 77;	//kontrolle ob erfolgreich sonst Abbruch mit Error Code
 121:grn_sht21.c   **** 	raw[2] = TWIReadNACK();				//receive checksum
 122:grn_sht21.c   **** 	TWIStop();							//close TWI
 123:grn_sht21.c   **** 	
 124:grn_sht21.c   **** 	messwert=(raw[0]<<8)|raw[1];						//8 bit werte zu 16bit Wert zusammensetzen
 125:grn_sht21.c   **** 	messwert &= ~0x003;								//Loescht letzte 2 Bits (Status Bits)
 126:grn_sht21.c   **** 	switch(measure_mode)
 127:grn_sht21.c   **** 	{
 128:grn_sht21.c   **** 		case T_HOLD:	rueckgabewert = 100*(-46.85 + 175.72/65536 * messwert);break;
 129:grn_sht21.c   **** 		case RH_HOLD:	rueckgabewert = 100*(-6.0 + 125.0/65536 * messwert);break; // return relative humid
 130:grn_sht21.c   **** 	}
 131:grn_sht21.c   **** 	 
 132:grn_sht21.c   **** 	if(sht21_checksum(raw,2,raw[2])) 	//check result with checksum
 133:grn_sht21.c   **** 	{
 134:grn_sht21.c   **** 		return 1;
 135:grn_sht21.c   **** 	}else return rueckgabewert;	
 136:grn_sht21.c   **** }//End of SHT21_read_temp
 191               		.loc 1 136 1 view .LVU47
 192 006a 0F90      		pop __tmp_reg__
 193 006c 0F90      		pop __tmp_reg__
 194 006e 0F90      		pop __tmp_reg__
 195 0070 0F90      		pop __tmp_reg__
 196 0072 0F90      		pop __tmp_reg__
 197 0074 DF91      		pop r29
 198 0076 CF91      		pop r28
 199 0078 1F91      		pop r17
 200 007a 0F91      		pop r16
 201 007c FF90      		pop r15
 202 007e 0895      		ret
 203               	.LVL15:
 204               	.L45:
  97:grn_sht21.c   **** 	TWIWrite(SHT21_W);			//send write adress
 205               		.loc 1 97 2 is_stmt 1 view .LVU48
 206 0080 80E8      		ldi r24,lo8(-128)
 207               	.LVL16:
  97:grn_sht21.c   **** 	TWIWrite(SHT21_W);			//send write adress
 208               		.loc 1 97 2 is_stmt 0 view .LVU49
 209 0082 0E94 0000 		call TWIWrite
 210               	.LVL17:
  98:grn_sht21.c   **** 	switch(measure_mode)
 211               		.loc 1 98 2 is_stmt 1 view .LVU50
  98:grn_sht21.c   **** 	switch(measure_mode)
 212               		.loc 1 98 5 is_stmt 0 view .LVU51
 213 0086 0E94 0000 		call TWIGetStatus
 214               	.LVL18:
  98:grn_sht21.c   **** 	switch(measure_mode)
 215               		.loc 1 98 4 view .LVU52
 216 008a 8831      		cpi r24,lo8(24)
 217 008c 01F4      		brne .L30
  99:grn_sht21.c   **** 	{
 218               		.loc 1 99 2 is_stmt 1 view .LVU53
 219 008e 2981      		ldd r18,Y+1
 220 0090 2223      		tst r18
 221 0092 01F0      		breq .L12
 222 0094 2130      		cpi r18,lo8(1)
 223 0096 01F0      		breq .L13
 224               	.L14:
 104:grn_sht21.c   **** 	TWIStart();								//restart TWI
 225               		.loc 1 104 2 view .LVU54
 104:grn_sht21.c   **** 	TWIStart();								//restart TWI
 226               		.loc 1 104 5 is_stmt 0 view .LVU55
 227 0098 0E94 0000 		call TWIGetStatus
 228               	.LVL19:
 104:grn_sht21.c   **** 	TWIStart();								//restart TWI
 229               		.loc 1 104 4 view .LVU56
 230 009c 8832      		cpi r24,lo8(40)
 231 009e 01F0      		breq .L46
 104:grn_sht21.c   **** 	TWIStart();								//restart TWI
 232               		.loc 1 104 35 view .LVU57
 233 00a0 81E2      		ldi r24,lo8(33)
 234 00a2 90E0      		ldi r25,0
 235 00a4 00C0      		rjmp .L9
 236               	.L13:
 102:grn_sht21.c   **** 	}
 237               		.loc 1 102 17 is_stmt 1 view .LVU58
 238 00a6 83EF      		ldi r24,lo8(-13)
 239 00a8 0E94 0000 		call TWIWrite
 240               	.LVL20:
 102:grn_sht21.c   **** 	}
 241               		.loc 1 102 48 view .LVU59
 102:grn_sht21.c   **** 	}
 242               		.loc 1 102 3 is_stmt 0 view .LVU60
 243 00ac 00C0      		rjmp .L14
 244               	.L46:
 105:grn_sht21.c   **** 	if(TWIGetStatus() != 0x10)return 44; 	//kontrolle ob erfolgreich sonst Abbruch mit Error Code
 245               		.loc 1 105 2 is_stmt 1 view .LVU61
 246 00ae 0E94 0000 		call TWIStart
 247               	.LVL21:
 106:grn_sht21.c   **** 	TWIWrite(SHT21_R);						//Adresse und lesen
 248               		.loc 1 106 2 view .LVU62
 106:grn_sht21.c   **** 	TWIWrite(SHT21_R);						//Adresse und lesen
 249               		.loc 1 106 5 is_stmt 0 view .LVU63
 250 00b2 0E94 0000 		call TWIGetStatus
 251               	.LVL22:
 106:grn_sht21.c   **** 	TWIWrite(SHT21_R);						//Adresse und lesen
 252               		.loc 1 106 4 view .LVU64
 253 00b6 8031      		cpi r24,lo8(16)
 254 00b8 01F0      		breq .L47
 106:grn_sht21.c   **** 	TWIWrite(SHT21_R);						//Adresse und lesen
 255               		.loc 1 106 35 view .LVU65
 256 00ba 8CE2      		ldi r24,lo8(44)
 257 00bc 90E0      		ldi r25,0
 258 00be 00C0      		rjmp .L9
 259               	.L12:
 101:grn_sht21.c   **** 		case RH_HOLD:	TWIWrite(SHT21_HUM_HOLDMASTER);break;	//Modus = Temperatur master hold = on
 260               		.loc 1 101 16 is_stmt 1 view .LVU66
 261 00c0 83EE      		ldi r24,lo8(-29)
 262 00c2 0E94 0000 		call TWIWrite
 263               	.LVL23:
 101:grn_sht21.c   **** 		case RH_HOLD:	TWIWrite(SHT21_HUM_HOLDMASTER);break;	//Modus = Temperatur master hold = on
 264               		.loc 1 101 48 view .LVU67
 101:grn_sht21.c   **** 		case RH_HOLD:	TWIWrite(SHT21_HUM_HOLDMASTER);break;	//Modus = Temperatur master hold = on
 265               		.loc 1 101 3 is_stmt 0 view .LVU68
 266 00c6 00C0      		rjmp .L14
 267               	.L30:
  98:grn_sht21.c   **** 	switch(measure_mode)
 268               		.loc 1 98 35 view .LVU69
 269 00c8 86E1      		ldi r24,lo8(22)
 270 00ca 90E0      		ldi r25,0
 271 00cc 00C0      		rjmp .L9
 272               	.L47:
 107:grn_sht21.c   **** 	if(TWIGetStatus() != 0x40)return 55;	//kontrolle ob erfolgreich sonst Abbruch mit Error Code
 273               		.loc 1 107 2 is_stmt 1 view .LVU70
 274 00ce 81E8      		ldi r24,lo8(-127)
 275 00d0 0E94 0000 		call TWIWrite
 276               	.LVL24:
 108:grn_sht21.c   **** 	
 277               		.loc 1 108 2 view .LVU71
 108:grn_sht21.c   **** 	
 278               		.loc 1 108 5 is_stmt 0 view .LVU72
 279 00d4 0E94 0000 		call TWIGetStatus
 280               	.LVL25:
 108:grn_sht21.c   **** 	
 281               		.loc 1 108 4 view .LVU73
 282 00d8 8034      		cpi r24,lo8(64)
 283 00da 01F0      		breq .+2
 284 00dc 00C0      		rjmp .L33
 110:grn_sht21.c   **** 	for(i=0;i<1000;i++)					//wait for timeout or
 285               		.loc 1 110 2 is_stmt 1 view .LVU74
 110:grn_sht21.c   **** 	for(i=0;i<1000;i++)					//wait for timeout or
 286               		.loc 1 110 7 is_stmt 0 view .LVU75
 287 00de 3D98      		cbi 0x7,5
 111:grn_sht21.c   **** 	{
 288               		.loc 1 111 2 is_stmt 1 view .LVU76
 289               	.LVL26:
 111:grn_sht21.c   **** 	{
 290               		.loc 1 111 10 view .LVU77
 110:grn_sht21.c   **** 	for(i=0;i<1000;i++)					//wait for timeout or
 291               		.loc 1 110 7 is_stmt 0 view .LVU78
 292 00e0 28EE      		ldi r18,lo8(-24)
 293 00e2 33E0      		ldi r19,lo8(3)
 294 00e4 00C0      		rjmp .L16
 295               	.LVL27:
 296               	.L48:
 111:grn_sht21.c   **** 	{
 297               		.loc 1 111 17 is_stmt 1 discriminator 2 view .LVU79
 111:grn_sht21.c   **** 	{
 298               		.loc 1 111 10 discriminator 2 view .LVU80
 111:grn_sht21.c   **** 	{
 299               		.loc 1 111 2 is_stmt 0 discriminator 2 view .LVU81
 300 00e6 2150      		subi r18,1
 301 00e8 3109      		sbc r19,__zero_reg__
 302               	.LVL28:
 111:grn_sht21.c   **** 	{
 303               		.loc 1 111 2 discriminator 2 view .LVU82
 304 00ea 01F0      		breq .L15
 305               	.LVL29:
 306               	.L16:
 113:grn_sht21.c   **** 	}
 307               		.loc 1 113 3 is_stmt 1 view .LVU83
 113:grn_sht21.c   **** 	}
 308               		.loc 1 113 11 is_stmt 0 view .LVU84
 309 00ec 96B1      		in r25,0x6
 310 00ee 9F7D      		andi r25,lo8(-33)
 311 00f0 96B9      		out 0x6,r25
 113:grn_sht21.c   **** 	}
 312               		.loc 1 113 5 view .LVU85
 313 00f2 9923      		tst r25
 314 00f4 01F0      		breq .L48
 315               	.LVL30:
 316               	.L15:
 115:grn_sht21.c   **** 	
 317               		.loc 1 115 2 is_stmt 1 view .LVU86
 115:grn_sht21.c   **** 	
 318               		.loc 1 115 7 is_stmt 0 view .LVU87
 319 00f6 3D9A      		sbi 0x7,5
 117:grn_sht21.c   **** 	if(TWIGetStatus() != 0x50)return 66;	//kontrolle ob erfolgreich sonst Abbruch mit Error Code
 320               		.loc 1 117 2 is_stmt 1 view .LVU88
 117:grn_sht21.c   **** 	if(TWIGetStatus() != 0x50)return 66;	//kontrolle ob erfolgreich sonst Abbruch mit Error Code
 321               		.loc 1 117 11 is_stmt 0 view .LVU89
 322 00f8 0E94 0000 		call TWIReadACK
 323               	.LVL31:
 324 00fc 182F      		mov r17,r24
 325               	.LVL32:
 118:grn_sht21.c   **** 	raw[1] = TWIReadACK();				//empfange LSB / durch NACK wird checksumme nicht empfangen
 326               		.loc 1 118 2 is_stmt 1 view .LVU90
 118:grn_sht21.c   **** 	raw[1] = TWIReadACK();				//empfange LSB / durch NACK wird checksumme nicht empfangen
 327               		.loc 1 118 5 is_stmt 0 view .LVU91
 328 00fe 0E94 0000 		call TWIGetStatus
 329               	.LVL33:
 118:grn_sht21.c   **** 	raw[1] = TWIReadACK();				//empfange LSB / durch NACK wird checksumme nicht empfangen
 330               		.loc 1 118 4 view .LVU92
 331 0102 8035      		cpi r24,lo8(80)
 332 0104 01F0      		breq .+2
 333 0106 00C0      		rjmp .L34
 119:grn_sht21.c   **** 	if(TWIGetStatus() != 0x50)return 77;	//kontrolle ob erfolgreich sonst Abbruch mit Error Code
 334               		.loc 1 119 2 is_stmt 1 view .LVU93
 119:grn_sht21.c   **** 	if(TWIGetStatus() != 0x50)return 77;	//kontrolle ob erfolgreich sonst Abbruch mit Error Code
 335               		.loc 1 119 11 is_stmt 0 view .LVU94
 336 0108 0E94 0000 		call TWIReadACK
 337               	.LVL34:
 338 010c 082F      		mov r16,r24
 339               	.LVL35:
 120:grn_sht21.c   **** 	raw[2] = TWIReadNACK();				//receive checksum
 340               		.loc 1 120 2 is_stmt 1 view .LVU95
 120:grn_sht21.c   **** 	raw[2] = TWIReadNACK();				//receive checksum
 341               		.loc 1 120 5 is_stmt 0 view .LVU96
 342 010e 0E94 0000 		call TWIGetStatus
 343               	.LVL36:
 120:grn_sht21.c   **** 	raw[2] = TWIReadNACK();				//receive checksum
 344               		.loc 1 120 4 view .LVU97
 345 0112 8035      		cpi r24,lo8(80)
 346 0114 01F0      		breq .+2
 347 0116 00C0      		rjmp .L35
 121:grn_sht21.c   **** 	TWIStop();							//close TWI
 348               		.loc 1 121 2 is_stmt 1 view .LVU98
 121:grn_sht21.c   **** 	TWIStop();							//close TWI
 349               		.loc 1 121 11 is_stmt 0 view .LVU99
 350 0118 0E94 0000 		call TWIReadNACK
 351               	.LVL37:
 352 011c F82E      		mov r15,r24
 353               	.LVL38:
 122:grn_sht21.c   **** 	
 354               		.loc 1 122 2 is_stmt 1 view .LVU100
 355 011e 0E94 0000 		call TWIStop
 356               	.LVL39:
 124:grn_sht21.c   **** 	messwert &= ~0x003;								//Loescht letzte 2 Bits (Status Bits)
 357               		.loc 1 124 2 view .LVU101
 124:grn_sht21.c   **** 	messwert &= ~0x003;								//Loescht letzte 2 Bits (Status Bits)
 358               		.loc 1 124 22 is_stmt 0 view .LVU102
 359 0122 C801      		movw r24,r16
 360               	.LVL40:
 125:grn_sht21.c   **** 	switch(measure_mode)
 361               		.loc 1 125 2 is_stmt 1 view .LVU103
 125:grn_sht21.c   **** 	switch(measure_mode)
 362               		.loc 1 125 11 is_stmt 0 view .LVU104
 363 0124 8C7F      		andi r24,252
 364               	.LVL41:
 126:grn_sht21.c   **** 	{
 365               		.loc 1 126 2 is_stmt 1 view .LVU105
 366 0126 3981      		ldd r19,Y+1
 367 0128 3323      		tst r19
 368 012a 01F4      		brne .+2
 369 012c 00C0      		rjmp .L17
 370 012e 3130      		cpi r19,lo8(1)
 371 0130 01F0      		breq .+2
 372 0132 00C0      		rjmp .L49
 129:grn_sht21.c   **** 	}
 373               		.loc 1 129 17 view .LVU106
 129:grn_sht21.c   **** 	}
 374               		.loc 1 129 57 is_stmt 0 view .LVU107
 375 0134 9C01      		movw r18,r24
 376 0136 50E0      		ldi r21,0
 377 0138 40E0      		ldi r20,0
 378 013a 2983      		std Y+1,r18
 379 013c 3A83      		std Y+2,r19
 380 013e 4B83      		std Y+3,r20
 381 0140 5C83      		std Y+4,r21
 382 0142 CA01      		movw r24,r20
 383               	.LVL42:
 129:grn_sht21.c   **** 	}
 384               		.loc 1 129 57 view .LVU108
 385 0144 B901      		movw r22,r18
 386 0146 0E94 0000 		call __floatunsisf
 387               	.LVL43:
 129:grn_sht21.c   **** 	}
 388               		.loc 1 129 57 view .LVU109
 389 014a 20E0      		ldi r18,0
 390 014c 30E0      		ldi r19,0
 391 014e 4AEF      		ldi r20,lo8(-6)
 392 0150 5AE3      		ldi r21,lo8(58)
 393 0152 6983      		std Y+1,r22
 394 0154 7A83      		std Y+2,r23
 395 0156 8B83      		std Y+3,r24
 396 0158 9C83      		std Y+4,r25
 397 015a 6981      		ldd r22,Y+1
 398 015c 7A81      		ldd r23,Y+2
 399 015e 8B81      		ldd r24,Y+3
 400 0160 9C81      		ldd r25,Y+4
 401 0162 0E94 0000 		call __mulsf3
 402               	.LVL44:
 129:grn_sht21.c   **** 	}
 403               		.loc 1 129 43 view .LVU110
 404 0166 20E0      		ldi r18,0
 405 0168 30E0      		ldi r19,0
 406 016a 40EC      		ldi r20,lo8(-64)
 407 016c 50E4      		ldi r21,lo8(64)
 408               	.L44:
 409 016e 6983      		std Y+1,r22
 410 0170 7A83      		std Y+2,r23
 411 0172 8B83      		std Y+3,r24
 412 0174 9C83      		std Y+4,r25
 413 0176 6981      		ldd r22,Y+1
 414 0178 7A81      		ldd r23,Y+2
 415 017a 8B81      		ldd r24,Y+3
 416 017c 9C81      		ldd r25,Y+4
 417 017e 0E94 0000 		call __subsf3
 418               	.LVL45:
 129:grn_sht21.c   **** 	}
 419               		.loc 1 129 36 view .LVU111
 420 0182 20E0      		ldi r18,0
 421 0184 30E0      		ldi r19,0
 422 0186 48EC      		ldi r20,lo8(-56)
 423 0188 52E4      		ldi r21,lo8(66)
 424 018a 6983      		std Y+1,r22
 425 018c 7A83      		std Y+2,r23
 426 018e 8B83      		std Y+3,r24
 427 0190 9C83      		std Y+4,r25
 428 0192 6981      		ldd r22,Y+1
 429 0194 7A81      		ldd r23,Y+2
 430 0196 8B81      		ldd r24,Y+3
 431 0198 9C81      		ldd r25,Y+4
 432 019a 0E94 0000 		call __mulsf3
 433               	.LVL46:
 129:grn_sht21.c   **** 	}
 434               		.loc 1 129 31 view .LVU112
 435 019e 6983      		std Y+1,r22
 436 01a0 7A83      		std Y+2,r23
 437 01a2 8B83      		std Y+3,r24
 438 01a4 9C83      		std Y+4,r25
 439 01a6 6981      		ldd r22,Y+1
 440 01a8 7A81      		ldd r23,Y+2
 441 01aa 8B81      		ldd r24,Y+3
 442 01ac 9C81      		ldd r25,Y+4
 443 01ae 0E94 0000 		call __fixsfsi
 444               	.LVL47:
 445 01b2 CB01      		movw r24,r22
 446               	.LVL48:
 129:grn_sht21.c   **** 	}
 447               		.loc 1 129 69 is_stmt 1 view .LVU113
 448               	.L19:
 132:grn_sht21.c   **** 	{
 449               		.loc 1 132 2 view .LVU114
 450               	.LBB23:
 451               	.LBI23:
 137:grn_sht21.c   **** 
 138:grn_sht21.c   **** uint8_t sht21_checksum(uint8_t data[], uint8_t no_of_bytes, uint8_t checksum) 
 452               		.loc 1 138 9 view .LVU115
 453               	.LBB24:
 139:grn_sht21.c   **** {
 140:grn_sht21.c   **** 	uint8_t crc = 0;	
 454               		.loc 1 140 2 view .LVU116
 141:grn_sht21.c   ****   	uint8_t byteCtr;
 455               		.loc 1 141 4 view .LVU117
 142:grn_sht21.c   **** 
 143:grn_sht21.c   ****  	 //calculates 8-Bit checksum with given polynomial
 144:grn_sht21.c   ****   	for (byteCtr = 0; byteCtr < no_of_bytes; ++byteCtr)
 456               		.loc 1 144 4 view .LVU118
 457               		.loc 1 144 22 view .LVU119
 145:grn_sht21.c   ****  	 { crc ^= (data[byteCtr]);
 458               		.loc 1 145 6 view .LVU120
 146:grn_sht21.c   ****  	   for (uint8_t bit = 8; bit > 0; --bit)
 459               		.loc 1 146 6 view .LVU121
 460               	.LBB25:
 461               		.loc 1 146 11 view .LVU122
 462               		.loc 1 146 28 view .LVU123
 463               	.LBE25:
 464               	.LBE24:
 465               	.LBE23:
 126:grn_sht21.c   **** 	{
 466               		.loc 1 126 2 is_stmt 0 view .LVU124
 467 01b4 28E0      		ldi r18,lo8(8)
 468               	.LBB30:
 469               	.LBB28:
 470               	.LBB26:
 147:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 471               		.loc 1 147 41 view .LVU125
 472 01b6 31E3      		ldi r19,lo8(49)
 473 01b8 00C0      		rjmp .L22
 474               	.LVL49:
 475               	.L40:
 148:grn_sht21.c   ****  	     else crc = (crc << 1);
 476               		.loc 1 148 13 is_stmt 1 view .LVU126
 477               		.loc 1 148 17 is_stmt 0 view .LVU127
 478 01ba 110F      		lsl r17
 479               	.LVL50:
 480               	.L24:
 146:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 481               		.loc 1 146 37 is_stmt 1 view .LVU128
 146:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 482               		.loc 1 146 28 view .LVU129
 146:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 483               		.loc 1 146 6 is_stmt 0 view .LVU130
 484 01bc 2150      		subi r18,lo8(-(-1))
 485               	.LVL51:
 146:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 486               		.loc 1 146 6 view .LVU131
 487 01be 01F0      		breq .L50
 488               	.LVL52:
 489               	.L22:
 147:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 490               		.loc 1 147 8 is_stmt 1 view .LVU132
 147:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 491               		.loc 1 147 11 is_stmt 0 view .LVU133
 492 01c0 17FF      		sbrs r17,7
 493 01c2 00C0      		rjmp .L40
 147:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 494               		.loc 1 147 24 is_stmt 1 view .LVU134
 147:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 495               		.loc 1 147 35 is_stmt 0 view .LVU135
 496 01c4 110F      		lsl r17
 497               	.LVL53:
 147:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 498               		.loc 1 147 41 view .LVU136
 499 01c6 1327      		eor r17,r19
 500               	.LVL54:
 147:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 501               		.loc 1 147 41 view .LVU137
 502 01c8 00C0      		rjmp .L24
 503               	.LVL55:
 504               	.L33:
 147:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 505               		.loc 1 147 41 view .LVU138
 506               	.LBE26:
 507               	.LBE28:
 508               	.LBE30:
 108:grn_sht21.c   **** 	
 509               		.loc 1 108 35 view .LVU139
 510 01ca 87E3      		ldi r24,lo8(55)
 511 01cc 90E0      		ldi r25,0
 512 01ce 00C0      		rjmp .L9
 513               	.LVL56:
 514               	.L34:
 118:grn_sht21.c   **** 	raw[1] = TWIReadACK();				//empfange LSB / durch NACK wird checksumme nicht empfangen
 515               		.loc 1 118 35 view .LVU140
 516 01d0 82E4      		ldi r24,lo8(66)
 517 01d2 90E0      		ldi r25,0
 518 01d4 00C0      		rjmp .L9
 519               	.LVL57:
 520               	.L35:
 120:grn_sht21.c   **** 	raw[2] = TWIReadNACK();				//receive checksum
 521               		.loc 1 120 35 view .LVU141
 522 01d6 8DE4      		ldi r24,lo8(77)
 523 01d8 90E0      		ldi r25,0
 524 01da 00C0      		rjmp .L9
 525               	.LVL58:
 526               	.L50:
 527               	.LBB31:
 528               	.LBB29:
 144:grn_sht21.c   ****  	 { crc ^= (data[byteCtr]);
 529               		.loc 1 144 45 is_stmt 1 view .LVU142
 144:grn_sht21.c   ****  	 { crc ^= (data[byteCtr]);
 530               		.loc 1 144 22 view .LVU143
 145:grn_sht21.c   ****  	   for (uint8_t bit = 8; bit > 0; --bit)
 531               		.loc 1 145 6 view .LVU144
 145:grn_sht21.c   ****  	   for (uint8_t bit = 8; bit > 0; --bit)
 532               		.loc 1 145 10 is_stmt 0 view .LVU145
 533 01dc 1027      		eor r17,r16
 534               	.LVL59:
 146:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 535               		.loc 1 146 6 is_stmt 1 view .LVU146
 536               	.LBB27:
 146:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 537               		.loc 1 146 11 view .LVU147
 146:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 538               		.loc 1 146 28 view .LVU148
 147:grn_sht21.c   ****  	     else crc = (crc << 1);
 539               		.loc 1 147 41 is_stmt 0 view .LVU149
 540 01de 21E3      		ldi r18,lo8(49)
 541 01e0 00C0      		rjmp .L27
 542               	.LVL60:
 543               	.L42:
 544               		.loc 1 148 13 is_stmt 1 view .LVU150
 545               		.loc 1 148 17 is_stmt 0 view .LVU151
 546 01e2 110F      		lsl r17
 547               	.LVL61:
 548               	.L29:
 146:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 549               		.loc 1 146 37 is_stmt 1 view .LVU152
 146:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 550               		.loc 1 146 28 view .LVU153
 146:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 551               		.loc 1 146 6 is_stmt 0 view .LVU154
 552 01e4 3D81      		ldd r19,Y+5
 553 01e6 3150      		subi r19,lo8(-(-1))
 554               	.LVL62:
 146:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 555               		.loc 1 146 6 view .LVU155
 556 01e8 3D83      		std Y+5,r19
 557 01ea 3323      		tst r19
 558 01ec 01F0      		breq .L51
 559               	.LVL63:
 560               	.L27:
 147:grn_sht21.c   ****  	     else crc = (crc << 1);
 561               		.loc 1 147 8 is_stmt 1 view .LVU156
 147:grn_sht21.c   ****  	     else crc = (crc << 1);
 562               		.loc 1 147 11 is_stmt 0 view .LVU157
 563 01ee 17FF      		sbrs r17,7
 564 01f0 00C0      		rjmp .L42
 147:grn_sht21.c   ****  	     else crc = (crc << 1);
 565               		.loc 1 147 24 is_stmt 1 view .LVU158
 147:grn_sht21.c   ****  	     else crc = (crc << 1);
 566               		.loc 1 147 35 is_stmt 0 view .LVU159
 567 01f2 110F      		lsl r17
 568               	.LVL64:
 147:grn_sht21.c   ****  	     else crc = (crc << 1);
 569               		.loc 1 147 41 view .LVU160
 570 01f4 1227      		eor r17,r18
 571               	.LVL65:
 147:grn_sht21.c   ****  	     else crc = (crc << 1);
 572               		.loc 1 147 41 view .LVU161
 573 01f6 00C0      		rjmp .L29
 574               	.LVL66:
 575               	.L51:
 147:grn_sht21.c   ****  	     else crc = (crc << 1);
 576               		.loc 1 147 41 view .LVU162
 577               	.LBE27:
 144:grn_sht21.c   ****  	 { crc ^= (data[byteCtr]);
 578               		.loc 1 144 45 is_stmt 1 view .LVU163
 144:grn_sht21.c   ****  	 { crc ^= (data[byteCtr]);
 579               		.loc 1 144 22 view .LVU164
 149:grn_sht21.c   ****  	   }
 150:grn_sht21.c   ****  	 }
 151:grn_sht21.c   ****  	 if (crc != checksum) return 1;
 580               		.loc 1 151 4 view .LVU165
 581               		.loc 1 151 7 is_stmt 0 view .LVU166
 582 01f8 F116      		cp r15,r17
 583 01fa 01F4      		brne .+2
 584 01fc 00C0      		rjmp .L9
 585               	.LBE29:
 586               	.LBE31:
 134:grn_sht21.c   **** 	}else return rueckgabewert;	
 587               		.loc 1 134 10 view .LVU167
 588 01fe 81E0      		ldi r24,lo8(1)
 589 0200 90E0      		ldi r25,0
 590               	.LVL67:
 134:grn_sht21.c   **** 	}else return rueckgabewert;	
 591               		.loc 1 134 10 view .LVU168
 592 0202 00C0      		rjmp .L9
 593               	.LVL68:
 594               	.L49:
 126:grn_sht21.c   **** 	{
 595               		.loc 1 126 2 view .LVU169
 596 0204 90E0      		ldi r25,0
 597 0206 80E0      		ldi r24,0
 598               	.LVL69:
 126:grn_sht21.c   **** 	{
 599               		.loc 1 126 2 view .LVU170
 600 0208 00C0      		rjmp .L19
 601               	.LVL70:
 602               	.L17:
 128:grn_sht21.c   **** 		case RH_HOLD:	rueckgabewert = 100*(-6.0 + 125.0/65536 * messwert);break; // return relative humid
 603               		.loc 1 128 16 is_stmt 1 view .LVU171
 128:grn_sht21.c   **** 		case RH_HOLD:	rueckgabewert = 100*(-6.0 + 125.0/65536 * messwert);break; // return relative humid
 604               		.loc 1 128 59 is_stmt 0 view .LVU172
 605 020a 9C01      		movw r18,r24
 606 020c 50E0      		ldi r21,0
 607 020e 40E0      		ldi r20,0
 608 0210 2983      		std Y+1,r18
 609 0212 3A83      		std Y+2,r19
 610 0214 4B83      		std Y+3,r20
 611 0216 5C83      		std Y+4,r21
 612 0218 CA01      		movw r24,r20
 613               	.LVL71:
 128:grn_sht21.c   **** 		case RH_HOLD:	rueckgabewert = 100*(-6.0 + 125.0/65536 * messwert);break; // return relative humid
 614               		.loc 1 128 59 view .LVU173
 615 021a B901      		movw r22,r18
 616 021c 0E94 0000 		call __floatunsisf
 617               	.LVL72:
 128:grn_sht21.c   **** 		case RH_HOLD:	rueckgabewert = 100*(-6.0 + 125.0/65536 * messwert);break; // return relative humid
 618               		.loc 1 128 59 view .LVU174
 619 0220 22E5      		ldi r18,lo8(82)
 620 0222 38EB      		ldi r19,lo8(-72)
 621 0224 4FE2      		ldi r20,lo8(47)
 622 0226 5BE3      		ldi r21,lo8(59)
 623 0228 6983      		std Y+1,r22
 624 022a 7A83      		std Y+2,r23
 625 022c 8B83      		std Y+3,r24
 626 022e 9C83      		std Y+4,r25
 627 0230 6981      		ldd r22,Y+1
 628 0232 7A81      		ldd r23,Y+2
 629 0234 8B81      		ldd r24,Y+3
 630 0236 9C81      		ldd r25,Y+4
 631 0238 0E94 0000 		call __mulsf3
 632               	.LVL73:
 128:grn_sht21.c   **** 		case RH_HOLD:	rueckgabewert = 100*(-6.0 + 125.0/65536 * messwert);break; // return relative humid
 633               		.loc 1 128 44 view .LVU175
 634 023c 26E6      		ldi r18,lo8(102)
 635 023e 36E6      		ldi r19,lo8(102)
 636 0240 4BE3      		ldi r20,lo8(59)
 637 0242 52E4      		ldi r21,lo8(66)
 638 0244 00C0      		rjmp .L44
 639               		.cfi_endproc
 640               	.LFE8:
 642               	.global	sht21_checksum
 644               	sht21_checksum:
 645               	.LVL74:
 646               	.LFB9:
 139:grn_sht21.c   **** 	uint8_t crc = 0;	
 647               		.loc 1 139 1 is_stmt 1 view -0
 648               		.cfi_startproc
 649               	/* prologue: function */
 650               	/* frame size = 0 */
 651               	/* stack size = 0 */
 652               	.L__stack_usage = 0
 140:grn_sht21.c   ****   	uint8_t byteCtr;
 653               		.loc 1 140 2 view .LVU177
 141:grn_sht21.c   **** 
 654               		.loc 1 141 4 view .LVU178
 144:grn_sht21.c   ****  	 { crc ^= (data[byteCtr]);
 655               		.loc 1 144 4 view .LVU179
 144:grn_sht21.c   ****  	 { crc ^= (data[byteCtr]);
 656               		.loc 1 144 22 view .LVU180
 144:grn_sht21.c   ****  	 { crc ^= (data[byteCtr]);
 657               		.loc 1 144 4 is_stmt 0 view .LVU181
 658 0246 6623      		tst r22
 659 0248 01F0      		breq .L53
 660 024a FC01      		movw r30,r24
 661 024c 9C01      		movw r18,r24
 662 024e 2F5F      		subi r18,-1
 663 0250 3F4F      		sbci r19,-1
 664 0252 6150      		subi r22,lo8(-(-1))
 665               	.LVL75:
 144:grn_sht21.c   ****  	 { crc ^= (data[byteCtr]);
 666               		.loc 1 144 4 view .LVU182
 667 0254 260F      		add r18,r22
 668 0256 311D      		adc r19,__zero_reg__
 140:grn_sht21.c   ****   	uint8_t byteCtr;
 669               		.loc 1 140 10 view .LVU183
 670 0258 60E0      		ldi r22,0
 671               	.LVL76:
 672               	.LBB32:
 147:grn_sht21.c   ****  	     else crc = (crc << 1);
 673               		.loc 1 147 41 view .LVU184
 674 025a 91E3      		ldi r25,lo8(49)
 675               	.LVL77:
 676               	.L57:
 147:grn_sht21.c   ****  	     else crc = (crc << 1);
 677               		.loc 1 147 41 view .LVU185
 678               	.LBE32:
 145:grn_sht21.c   ****  	   for (uint8_t bit = 8; bit > 0; --bit)
 679               		.loc 1 145 6 is_stmt 1 view .LVU186
 145:grn_sht21.c   ****  	   for (uint8_t bit = 8; bit > 0; --bit)
 680               		.loc 1 145 18 is_stmt 0 view .LVU187
 681 025c 8191      		ld r24,Z+
 682               	.LVL78:
 145:grn_sht21.c   ****  	   for (uint8_t bit = 8; bit > 0; --bit)
 683               		.loc 1 145 10 view .LVU188
 684 025e 6827      		eor r22,r24
 685               	.LVL79:
 146:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 686               		.loc 1 146 6 is_stmt 1 view .LVU189
 687               	.LBB33:
 146:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 688               		.loc 1 146 11 view .LVU190
 146:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 689               		.loc 1 146 28 view .LVU191
 690               	.LBE33:
 145:grn_sht21.c   ****  	   for (uint8_t bit = 8; bit > 0; --bit)
 691               		.loc 1 145 10 is_stmt 0 view .LVU192
 692 0260 88E0      		ldi r24,lo8(8)
 693 0262 00C0      		rjmp .L56
 694               	.LVL80:
 695               	.L54:
 696               	.LBB34:
 148:grn_sht21.c   ****  	   }
 697               		.loc 1 148 13 is_stmt 1 view .LVU193
 148:grn_sht21.c   ****  	   }
 698               		.loc 1 148 17 is_stmt 0 view .LVU194
 699 0264 660F      		lsl r22
 700               	.LVL81:
 146:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 701               		.loc 1 146 37 is_stmt 1 view .LVU195
 146:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 702               		.loc 1 146 28 view .LVU196
 146:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 703               		.loc 1 146 6 is_stmt 0 view .LVU197
 704 0266 8150      		subi r24,lo8(-(-1))
 705               	.LVL82:
 146:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 706               		.loc 1 146 6 view .LVU198
 707 0268 01F0      		breq .L64
 708               	.LVL83:
 709               	.L56:
 147:grn_sht21.c   ****  	     else crc = (crc << 1);
 710               		.loc 1 147 8 is_stmt 1 view .LVU199
 147:grn_sht21.c   ****  	     else crc = (crc << 1);
 711               		.loc 1 147 11 is_stmt 0 view .LVU200
 712 026a 67FF      		sbrs r22,7
 713 026c 00C0      		rjmp .L54
 147:grn_sht21.c   ****  	     else crc = (crc << 1);
 714               		.loc 1 147 24 is_stmt 1 discriminator 1 view .LVU201
 147:grn_sht21.c   ****  	     else crc = (crc << 1);
 715               		.loc 1 147 35 is_stmt 0 discriminator 1 view .LVU202
 716 026e 660F      		lsl r22
 717               	.LVL84:
 147:grn_sht21.c   ****  	     else crc = (crc << 1);
 718               		.loc 1 147 41 discriminator 1 view .LVU203
 719 0270 6927      		eor r22,r25
 720               	.LVL85:
 146:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 721               		.loc 1 146 37 is_stmt 1 discriminator 1 view .LVU204
 146:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 722               		.loc 1 146 28 discriminator 1 view .LVU205
 146:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 723               		.loc 1 146 6 is_stmt 0 discriminator 1 view .LVU206
 724 0272 8150      		subi r24,lo8(-(-1))
 725               	.LVL86:
 146:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 726               		.loc 1 146 6 discriminator 1 view .LVU207
 727 0274 01F4      		brne .L56
 728               	.L64:
 146:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 729               		.loc 1 146 6 discriminator 1 view .LVU208
 730               	.LBE34:
 144:grn_sht21.c   ****  	 { crc ^= (data[byteCtr]);
 731               		.loc 1 144 45 is_stmt 1 discriminator 2 view .LVU209
 732               	.LVL87:
 144:grn_sht21.c   ****  	 { crc ^= (data[byteCtr]);
 733               		.loc 1 144 22 discriminator 2 view .LVU210
 144:grn_sht21.c   ****  	 { crc ^= (data[byteCtr]);
 734               		.loc 1 144 4 is_stmt 0 discriminator 2 view .LVU211
 735 0276 E217      		cp r30,r18
 736 0278 F307      		cpc r31,r19
 737 027a 01F4      		brne .L57
 738               	.LVL88:
 739               	.L53:
 740               		.loc 1 151 4 is_stmt 1 view .LVU212
 741               		.loc 1 151 7 is_stmt 0 view .LVU213
 742 027c 81E0      		ldi r24,lo8(1)
 743 027e 4613      		cpse r20,r22
 744               	/* epilogue start */
 152:grn_sht21.c   ****  	 else return 0;
 153:grn_sht21.c   **** }
 745               		.loc 1 153 1 view .LVU214
 746 0280 0895      		ret
 747               	.L65:
 151:grn_sht21.c   ****  	 else return 0;
 748               		.loc 1 151 7 view .LVU215
 749 0282 80E0      		ldi r24,0
 750               	/* epilogue start */
 751               		.loc 1 153 1 view .LVU216
 752 0284 0895      		ret
 753               		.cfi_endproc
 754               	.LFE9:
 756               	.Letext0:
 757               		.file 4 "/usr/avr/include/stdint.h"
 758               		.file 5 "grn_TWI.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 grn_sht21.c
     /tmp/ccFCQLWq.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccFCQLWq.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccFCQLWq.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccFCQLWq.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccFCQLWq.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccFCQLWq.s:12     .text:0000000000000000 sht21_init
     /tmp/ccFCQLWq.s:126    .text:0000000000000044 sht21_measure
     /tmp/ccFCQLWq.s:644    .text:0000000000000246 sht21_checksum

UNDEFINED SYMBOLS
TWIStart
TWIGetStatus
TWIWrite
TWIStop
__floatunsisf
__mulsf3
__subsf3
__fixsfsi
TWIReadACK
TWIReadNACK
