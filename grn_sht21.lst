   1               		.file	"grn_sht21.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	sht21_init
  12               	sht21_init:
  13               	.LFB7:
  14               		.file 1 "grn_sht21.c"
   1:grn_sht21.c   **** /*	Library File
   2:grn_sht21.c   ****  * 
   3:grn_sht21.c   ****  * 	Sensirion SHT21 Sensor (Temperature / Humidity)
   4:grn_sht21.c   ****  *
   5:grn_sht21.c   ****  * 	grn; Apr 15
   6:grn_sht21.c   ****  */
   7:grn_sht21.c   ****  #define F_CPU 8000000UL                 // set the CPU clock
   8:grn_sht21.c   **** #include <stdio.h>
   9:grn_sht21.c   **** #include <avr/io.h>
  10:grn_sht21.c   **** #include <util/delay.h>
  11:grn_sht21.c   **** #include "grn_TWI.h"
  12:grn_sht21.c   **** #include "grn_sht21.h"
  13:grn_sht21.c   **** 
  14:grn_sht21.c   **** #define SHT21_W 0x80				//SHT21 Adresse und schreiben 	0x80
  15:grn_sht21.c   **** #define SHT21_R 0x81				//SHT21 Adresse und lesen		0x81
  16:grn_sht21.c   **** #define SHT21_TEMP_HOLDMASTER 0xE3		//Tempreature hold master = on =>0b11100011
  17:grn_sht21.c   **** #define SHT21_HUM_HOLDMASTER 0xF3		//Humidity hold master = on => 0b11100101
  18:grn_sht21.c   **** #define SHT21_SOFTRESET 0xFE				//Softreset
  19:grn_sht21.c   **** #define POLYNOMINAL 0x131				//P(x) = x^8+x^5+x^4+1 = 0b100110001
  20:grn_sht21.c   **** 
  21:grn_sht21.c   **** #define T_HOLD 	0
  22:grn_sht21.c   **** #define RH_HOLD 	1
  23:grn_sht21.c   **** 
  24:grn_sht21.c   **** typedef float ft;						//Float VAriable zur Umrechnung vor Rueckgabe
  25:grn_sht21.c   **** 
  26:grn_sht21.c   **** 
  27:grn_sht21.c   **** uint8_t sht21_init(void)
  28:grn_sht21.c   **** {
  15               		.loc 1 28 1 view -0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  29:grn_sht21.c   **** 	/*	
  30:grn_sht21.c   **** 	 * Softreset Sensor
  31:grn_sht21.c   **** 	 */
  32:grn_sht21.c   **** 	TWIStart();
  21               		.loc 1 32 2 view .LVU1
  22 0000 0E94 0000 		call TWIStart
  23               	.LVL0:
  33:grn_sht21.c   **** 	if(TWIGetStatus() != 0x08)return 1; 
  24               		.loc 1 33 2 view .LVU2
  25               		.loc 1 33 5 is_stmt 0 view .LVU3
  26 0004 0E94 0000 		call TWIGetStatus
  27               	.LVL1:
  28               		.loc 1 33 4 view .LVU4
  29 0008 8830      		cpi r24,lo8(8)
  30 000a 01F0      		breq .L7
  31               		.loc 1 33 35 view .LVU5
  32 000c 81E0      		ldi r24,lo8(1)
  33 000e 0895      		ret
  34               	.L7:
  34:grn_sht21.c   **** 	TWIWrite(SHT21_W);
  35               		.loc 1 34 2 is_stmt 1 view .LVU6
  36 0010 80E8      		ldi r24,lo8(-128)
  37 0012 0E94 0000 		call TWIWrite
  38               	.LVL2:
  35:grn_sht21.c   **** 	if(TWIGetStatus() != 0x18)return 2;
  39               		.loc 1 35 2 view .LVU7
  40               		.loc 1 35 5 is_stmt 0 view .LVU8
  41 0016 0E94 0000 		call TWIGetStatus
  42               	.LVL3:
  43               		.loc 1 35 4 view .LVU9
  44 001a 8831      		cpi r24,lo8(24)
  45 001c 01F0      		breq .L8
  46               		.loc 1 35 35 view .LVU10
  47 001e 82E0      		ldi r24,lo8(2)
  48 0020 0895      		ret
  49               	.L8:
  36:grn_sht21.c   **** 	TWIWrite(SHT21_SOFTRESET);
  50               		.loc 1 36 2 is_stmt 1 view .LVU11
  51 0022 8EEF      		ldi r24,lo8(-2)
  52 0024 0E94 0000 		call TWIWrite
  53               	.LVL4:
  37:grn_sht21.c   **** 	if(TWIGetStatus() != 0x28)return 3;
  54               		.loc 1 37 2 view .LVU12
  55               		.loc 1 37 5 is_stmt 0 view .LVU13
  56 0028 0E94 0000 		call TWIGetStatus
  57               	.LVL5:
  58               		.loc 1 37 4 view .LVU14
  59 002c 8832      		cpi r24,lo8(40)
  60 002e 01F4      		brne .L5
  38:grn_sht21.c   **** 	TWIStop();
  61               		.loc 1 38 2 is_stmt 1 view .LVU15
  62 0030 0E94 0000 		call TWIStop
  63               	.LVL6:
  39:grn_sht21.c   **** 	_delay_ms(15);	//Startuptime after Reset <15ms (Datasheet)
  64               		.loc 1 39 2 view .LVU16
  65               	.LBB12:
  66               	.LBI12:
  67               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
  68               		.loc 2 166 1 view .LVU17
  69               	.LBB13:
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
  70               		.loc 2 168 2 view .LVU18
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/avr/include/util/delay.h **** 
 189:/usr/avr/include/util/delay.h **** #else
 190:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
  71               		.loc 2 190 2 view .LVU19
 191:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
  72               		.loc 2 191 2 view .LVU20
 192:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
  73               		.loc 2 192 2 view .LVU21
 193:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
  74               		.loc 2 194 7 view .LVU22
 195:/usr/avr/include/util/delay.h **** 	{
 196:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/avr/include/util/delay.h **** 		{
 200:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/avr/include/util/delay.h **** 		}
 204:/usr/avr/include/util/delay.h **** 		return;
 205:/usr/avr/include/util/delay.h **** 	}
 206:/usr/avr/include/util/delay.h **** 	else
 207:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
  75               		.loc 2 207 3 view .LVU23
 208:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
  76               		.loc 2 208 2 view .LVU24
  77               	.LBB14:
  78               	.LBI14:
  79               		.file 3 "/usr/avr/include/util/delay_basic.h"
   1:/usr/avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:/usr/avr/include/util/delay_basic.h ****    All rights reserved.
   4:/usr/avr/include/util/delay_basic.h **** 
   5:/usr/avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/avr/include/util/delay_basic.h **** 
   8:/usr/avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/avr/include/util/delay_basic.h **** 
  11:/usr/avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:/usr/avr/include/util/delay_basic.h ****      distribution.
  15:/usr/avr/include/util/delay_basic.h **** 
  16:/usr/avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:/usr/avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:/usr/avr/include/util/delay_basic.h **** 
  20:/usr/avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/avr/include/util/delay_basic.h **** 
  32:/usr/avr/include/util/delay_basic.h **** /* $Id: delay_basic.h 2453 2014-10-19 08:18:11Z saaadhu $ */
  33:/usr/avr/include/util/delay_basic.h **** 
  34:/usr/avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:/usr/avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:/usr/avr/include/util/delay_basic.h **** 
  37:/usr/avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:/usr/avr/include/util/delay_basic.h **** 
  39:/usr/avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  40:/usr/avr/include/util/delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:/usr/avr/include/util/delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:/usr/avr/include/util/delay_basic.h **** #endif
  43:/usr/avr/include/util/delay_basic.h **** 
  44:/usr/avr/include/util/delay_basic.h **** /** \file */
  45:/usr/avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:/usr/avr/include/util/delay_basic.h ****     \code
  47:/usr/avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  48:/usr/avr/include/util/delay_basic.h ****     \endcode
  49:/usr/avr/include/util/delay_basic.h **** 
  50:/usr/avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  51:/usr/avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:/usr/avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:/usr/avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:/usr/avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:/usr/avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:/usr/avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  57:/usr/avr/include/util/delay_basic.h **** 
  58:/usr/avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:/usr/avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:/usr/avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  61:/usr/avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  62:/usr/avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:/usr/avr/include/util/delay_basic.h ****     to the overall delay time.
  64:/usr/avr/include/util/delay_basic.h **** 
  65:/usr/avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:/usr/avr/include/util/delay_basic.h **** 
  67:/usr/avr/include/util/delay_basic.h **** */
  68:/usr/avr/include/util/delay_basic.h **** 
  69:/usr/avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:/usr/avr/include/util/delay_basic.h **** 
  71:/usr/avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:/usr/avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:/usr/avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:/usr/avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:/usr/avr/include/util/delay_basic.h ****     register.
  76:/usr/avr/include/util/delay_basic.h **** 
  77:/usr/avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:/usr/avr/include/util/delay_basic.h ****     can be achieved.
  79:/usr/avr/include/util/delay_basic.h **** */
  80:/usr/avr/include/util/delay_basic.h **** void
  81:/usr/avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:/usr/avr/include/util/delay_basic.h **** {
  83:/usr/avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:/usr/avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:/usr/avr/include/util/delay_basic.h **** 		"brne 1b"
  86:/usr/avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:/usr/avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:/usr/avr/include/util/delay_basic.h **** 	);
  89:/usr/avr/include/util/delay_basic.h **** }
  90:/usr/avr/include/util/delay_basic.h **** 
  91:/usr/avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:/usr/avr/include/util/delay_basic.h **** 
  93:/usr/avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:/usr/avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:/usr/avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:/usr/avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:/usr/avr/include/util/delay_basic.h ****     counter register pair.
  98:/usr/avr/include/util/delay_basic.h **** 
  99:/usr/avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:/usr/avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:/usr/avr/include/util/delay_basic.h ****  */
 102:/usr/avr/include/util/delay_basic.h **** void
 103:/usr/avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
  80               		.loc 3 103 1 view .LVU25
  81               	.LBB15:
 104:/usr/avr/include/util/delay_basic.h **** {
 105:/usr/avr/include/util/delay_basic.h **** 	__asm__ volatile (
  82               		.loc 3 105 2 view .LVU26
  83 0034 80E3      		ldi r24,lo8(48)
  84 0036 95E7      		ldi r25,lo8(117)
  85               	/* #APP */
  86               	 ;  105 "/usr/avr/include/util/delay_basic.h" 1
  87 0038 0197      		1: sbiw r24,1
  88 003a 01F4      		brne 1b
  89               	 ;  0 "" 2
  90               	.LVL7:
  91               		.loc 3 105 2 is_stmt 0 view .LVU27
  92               	/* #NOAPP */
  93               	.LBE15:
  94               	.LBE14:
  95               	.LBE13:
  96               	.LBE12:
  40:grn_sht21.c   **** 	return 0;
  97               		.loc 1 40 9 view .LVU28
  98 003c 80E0      		ldi r24,0
  99               	.LBB19:
 100               	.LBB18:
 101               	.LBB17:
 102               	.LBB16:
 106:/usr/avr/include/util/delay_basic.h **** 		"1: sbiw %0,1" "\n\t"
 107:/usr/avr/include/util/delay_basic.h **** 		"brne 1b"
 108:/usr/avr/include/util/delay_basic.h **** 		: "=w" (__count)
 109:/usr/avr/include/util/delay_basic.h **** 		: "0" (__count)
 110:/usr/avr/include/util/delay_basic.h **** 	);
 111:/usr/avr/include/util/delay_basic.h **** }
 103               		.loc 3 111 1 view .LVU29
 104 003e 0895      		ret
 105               	.LVL8:
 106               	.L5:
 107               		.loc 3 111 1 view .LVU30
 108               	.LBE16:
 109               	.LBE17:
 110               	.LBE18:
 111               	.LBE19:
  37:grn_sht21.c   **** 	TWIStop();
 112               		.loc 1 37 35 view .LVU31
 113 0040 83E0      		ldi r24,lo8(3)
 114               	/* epilogue start */
  41:grn_sht21.c   **** }
 115               		.loc 1 41 1 view .LVU32
 116 0042 0895      		ret
 117               		.cfi_endproc
 118               	.LFE7:
 120               	.global	sht21_checksum
 122               	sht21_checksum:
 123               	.LVL9:
 124               	.LFB9:
  42:grn_sht21.c   **** 
  43:grn_sht21.c   **** float sht21_measure(uint8_t measure_mode)
  44:grn_sht21.c   **** {
  45:grn_sht21.c   **** 	/*
  46:grn_sht21.c   **** 	 * 	Temperaturmessung / Überprüfung der Checksumme	
  47:grn_sht21.c   **** 	 * 
  48:grn_sht21.c   **** 	 * 	Rückgabewert: 	16 bit Temperaturwert x 100 
  49:grn_sht21.c   **** 	 * 					(letzte 2 Stellen sind Nachkommastellen)
  50:grn_sht21.c   **** 	 * 	Checksum error: Rückgabewert = 99;
  51:grn_sht21.c   **** 	 */ 
  52:grn_sht21.c   **** 	 
  53:grn_sht21.c   **** 	uint8_t raw[]={0,0,0};
  54:grn_sht21.c   **** 	uint16_t messwert;
  55:grn_sht21.c   **** 	float rueckgabewert;
  56:grn_sht21.c   **** 	
  57:grn_sht21.c   **** 	messwert=0;
  58:grn_sht21.c   **** 	rueckgabewert=0;
  59:grn_sht21.c   **** 
  60:grn_sht21.c   **** 		
  61:grn_sht21.c   **** 	TWIStart();							//start TWI
  62:grn_sht21.c   **** 	if(TWIGetStatus() != 0x08)return 4; //kontrolle ob erfolgreich sonst Abbruch mit Error Code
  63:grn_sht21.c   **** 	TWIWrite(SHT21_W);					//Adresse und Schreiben
  64:grn_sht21.c   **** 	if(TWIGetStatus() != 0x18)return 5;	//kontrolle ob erfolgreich sonst Abbruch mit Error Code
  65:grn_sht21.c   **** 	switch(measure_mode)
  66:grn_sht21.c   **** 	{
  67:grn_sht21.c   **** 		case T_HOLD:	TWIWrite(SHT21_TEMP_HOLDMASTER);break;	//Modus = Temperatur master hold = on
  68:grn_sht21.c   **** 		case RH_HOLD:	TWIWrite(SHT21_HUM_HOLDMASTER);break;	//Modus = Temperatur master hold = on
  69:grn_sht21.c   **** 	}
  70:grn_sht21.c   **** 	if(TWIGetStatus() != 0x28)return 6;	//kontrolle ob erfolgreich sonst Abbruch mit Error Code
  71:grn_sht21.c   **** 
  72:grn_sht21.c   **** 	DDRC &= ~(1<<PC5);					//set SCL as Input
  73:grn_sht21.c   **** 	while(!(PINC &= ~(1<<PC5)));		//wait to end conversion (Master hold mode)
  74:grn_sht21.c   **** 	DDRC |= (1<<PC5);					//set SCL as Output
  75:grn_sht21.c   **** 
  76:grn_sht21.c   **** 	TWIStart();							//restart TWI
  77:grn_sht21.c   **** 	if(TWIGetStatus() != 0x10)return 7; //kontrolle ob erfolgreich sonst Abbruch mit Error Code
  78:grn_sht21.c   **** 	TWIWrite(SHT21_R);					//Adresse und lesen
  79:grn_sht21.c   **** 	if(TWIGetStatus() != 0x40)return 8;	//kontrolle ob erfolgreich sonst Abbruch mit Error Code
  80:grn_sht21.c   **** 	raw[0] = TWIReadACK();				//empfange MSB
  81:grn_sht21.c   **** 	if(TWIGetStatus() != 0x50)return 9;	//kontrolle ob erfolgreich sonst Abbruch mit Error Code
  82:grn_sht21.c   **** 	raw[1] = TWIReadACK();				//empfange LSB / durch NACK wird checksumme nicht empfangen
  83:grn_sht21.c   **** 	if(TWIGetStatus() != 0x50)return 9;	//kontrolle ob erfolgreich sonst Abbruch mit Error Code
  84:grn_sht21.c   **** 	raw[2] = TWIReadNACK();				//receive checksum
  85:grn_sht21.c   **** 	TWIStop();							//close TWI
  86:grn_sht21.c   **** 	
  87:grn_sht21.c   **** 	messwert=(raw[0]<<8)|raw[1];						//8 bit werte zu 16bit Wert zusammensetzen
  88:grn_sht21.c   **** 	messwert &= ~0x003;								//Loescht letzte 2 Bits (Status Bits)
  89:grn_sht21.c   **** 	switch(measure_mode)
  90:grn_sht21.c   **** 	{
  91:grn_sht21.c   **** 		case T_HOLD:	rueckgabewert = (-46.85 + 175.72/65536 * (float)messwert);break;
  92:grn_sht21.c   **** 		case RH_HOLD:	rueckgabewert = (-6.0 + 125.0/65536 * (float)messwert);break; // return relative hu
  93:grn_sht21.c   **** 	}
  94:grn_sht21.c   **** 	 
  95:grn_sht21.c   **** 	if(sht21_checksum(raw,2,raw[2])) 	//check result with checksum
  96:grn_sht21.c   **** 	{
  97:grn_sht21.c   **** 		return 1;
  98:grn_sht21.c   **** 	}else return rueckgabewert;	
  99:grn_sht21.c   **** }//End of SHT21_read_temp
 100:grn_sht21.c   **** 
 101:grn_sht21.c   **** uint8_t sht21_checksum(uint8_t data[], uint8_t no_of_bytes, uint8_t checksum) 
 102:grn_sht21.c   **** {
 125               		.loc 1 102 1 is_stmt 1 view -0
 126               		.cfi_startproc
 127               	/* prologue: function */
 128               	/* frame size = 0 */
 129               	/* stack size = 0 */
 130               	.L__stack_usage = 0
 103:grn_sht21.c   **** 	uint8_t crc = 0;	
 131               		.loc 1 103 2 view .LVU34
 104:grn_sht21.c   ****   	uint8_t byteCtr;
 132               		.loc 1 104 4 view .LVU35
 105:grn_sht21.c   **** 
 106:grn_sht21.c   ****  	 //calculates 8-Bit checksum with given polynomial
 107:grn_sht21.c   ****   	for (byteCtr = 0; byteCtr < no_of_bytes; ++byteCtr)
 133               		.loc 1 107 4 view .LVU36
 134               		.loc 1 107 22 view .LVU37
 135               		.loc 1 107 4 is_stmt 0 view .LVU38
 136 0044 6623      		tst r22
 137 0046 01F0      		breq .L10
 138 0048 FC01      		movw r30,r24
 139 004a 9C01      		movw r18,r24
 140 004c 2F5F      		subi r18,-1
 141 004e 3F4F      		sbci r19,-1
 142 0050 6150      		subi r22,lo8(-(-1))
 143               	.LVL10:
 144               		.loc 1 107 4 view .LVU39
 145 0052 260F      		add r18,r22
 146 0054 311D      		adc r19,__zero_reg__
 103:grn_sht21.c   ****   	uint8_t byteCtr;
 147               		.loc 1 103 10 view .LVU40
 148 0056 60E0      		ldi r22,0
 149               	.LVL11:
 150               	.LBB20:
 108:grn_sht21.c   ****  	 { crc ^= (data[byteCtr]);
 109:grn_sht21.c   ****  	   for (uint8_t bit = 8; bit > 0; --bit)
 110:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 151               		.loc 1 110 41 view .LVU41
 152 0058 91E3      		ldi r25,lo8(49)
 153               	.LVL12:
 154               	.L14:
 155               		.loc 1 110 41 view .LVU42
 156               	.LBE20:
 108:grn_sht21.c   ****  	 { crc ^= (data[byteCtr]);
 157               		.loc 1 108 6 is_stmt 1 view .LVU43
 108:grn_sht21.c   ****  	 { crc ^= (data[byteCtr]);
 158               		.loc 1 108 18 is_stmt 0 view .LVU44
 159 005a 8191      		ld r24,Z+
 160               	.LVL13:
 108:grn_sht21.c   ****  	 { crc ^= (data[byteCtr]);
 161               		.loc 1 108 10 view .LVU45
 162 005c 6827      		eor r22,r24
 163               	.LVL14:
 109:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 164               		.loc 1 109 6 is_stmt 1 view .LVU46
 165               	.LBB21:
 109:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 166               		.loc 1 109 11 view .LVU47
 109:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 167               		.loc 1 109 28 view .LVU48
 168               	.LBE21:
 108:grn_sht21.c   ****  	 { crc ^= (data[byteCtr]);
 169               		.loc 1 108 10 is_stmt 0 view .LVU49
 170 005e 88E0      		ldi r24,lo8(8)
 171 0060 00C0      		rjmp .L13
 172               	.LVL15:
 173               	.L11:
 174               	.LBB22:
 111:grn_sht21.c   ****  	     else crc = (crc << 1);
 175               		.loc 1 111 13 is_stmt 1 view .LVU50
 176               		.loc 1 111 17 is_stmt 0 view .LVU51
 177 0062 660F      		lsl r22
 178               	.LVL16:
 109:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 179               		.loc 1 109 37 is_stmt 1 view .LVU52
 109:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 180               		.loc 1 109 28 view .LVU53
 109:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 181               		.loc 1 109 6 is_stmt 0 view .LVU54
 182 0064 8150      		subi r24,lo8(-(-1))
 183               	.LVL17:
 109:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 184               		.loc 1 109 6 view .LVU55
 185 0066 01F0      		breq .L21
 186               	.LVL18:
 187               	.L13:
 110:grn_sht21.c   ****  	     else crc = (crc << 1);
 188               		.loc 1 110 8 is_stmt 1 view .LVU56
 110:grn_sht21.c   ****  	     else crc = (crc << 1);
 189               		.loc 1 110 11 is_stmt 0 view .LVU57
 190 0068 67FF      		sbrs r22,7
 191 006a 00C0      		rjmp .L11
 110:grn_sht21.c   ****  	     else crc = (crc << 1);
 192               		.loc 1 110 24 is_stmt 1 discriminator 1 view .LVU58
 110:grn_sht21.c   ****  	     else crc = (crc << 1);
 193               		.loc 1 110 35 is_stmt 0 discriminator 1 view .LVU59
 194 006c 660F      		lsl r22
 195               	.LVL19:
 110:grn_sht21.c   ****  	     else crc = (crc << 1);
 196               		.loc 1 110 41 discriminator 1 view .LVU60
 197 006e 6927      		eor r22,r25
 198               	.LVL20:
 109:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 199               		.loc 1 109 37 is_stmt 1 discriminator 1 view .LVU61
 109:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 200               		.loc 1 109 28 discriminator 1 view .LVU62
 109:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 201               		.loc 1 109 6 is_stmt 0 discriminator 1 view .LVU63
 202 0070 8150      		subi r24,lo8(-(-1))
 203               	.LVL21:
 109:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 204               		.loc 1 109 6 discriminator 1 view .LVU64
 205 0072 01F4      		brne .L13
 206               	.L21:
 109:grn_sht21.c   ****  	   { if (crc & 0x80) crc = (crc << 1) ^ POLYNOMINAL;
 207               		.loc 1 109 6 discriminator 1 view .LVU65
 208               	.LBE22:
 107:grn_sht21.c   ****  	 { crc ^= (data[byteCtr]);
 209               		.loc 1 107 45 is_stmt 1 discriminator 2 view .LVU66
 210               	.LVL22:
 107:grn_sht21.c   ****  	 { crc ^= (data[byteCtr]);
 211               		.loc 1 107 22 discriminator 2 view .LVU67
 107:grn_sht21.c   ****  	 { crc ^= (data[byteCtr]);
 212               		.loc 1 107 4 is_stmt 0 discriminator 2 view .LVU68
 213 0074 E217      		cp r30,r18
 214 0076 F307      		cpc r31,r19
 215 0078 01F4      		brne .L14
 216               	.LVL23:
 217               	.L10:
 112:grn_sht21.c   ****  	   }
 113:grn_sht21.c   ****  	 }
 114:grn_sht21.c   ****  	 if (crc != checksum) return 1;
 218               		.loc 1 114 4 is_stmt 1 view .LVU69
 219               		.loc 1 114 7 is_stmt 0 view .LVU70
 220 007a 81E0      		ldi r24,lo8(1)
 221 007c 4613      		cpse r20,r22
 222               	/* epilogue start */
 115:grn_sht21.c   ****  	 else return 0;
 116:grn_sht21.c   **** }
 223               		.loc 1 116 1 view .LVU71
 224 007e 0895      		ret
 225               	.L22:
 114:grn_sht21.c   ****  	 else return 0;
 226               		.loc 1 114 7 view .LVU72
 227 0080 80E0      		ldi r24,0
 228               	/* epilogue start */
 229               		.loc 1 116 1 view .LVU73
 230 0082 0895      		ret
 231               		.cfi_endproc
 232               	.LFE9:
 234               	.global	__floatunsisf
 235               	.global	__mulsf3
 236               	.global	__subsf3
 237               	.global	sht21_measure
 239               	sht21_measure:
 240               	.LVL24:
 241               	.LFB8:
  44:grn_sht21.c   **** 	/*
 242               		.loc 1 44 1 is_stmt 1 view -0
 243               		.cfi_startproc
  44:grn_sht21.c   **** 	/*
 244               		.loc 1 44 1 is_stmt 0 view .LVU75
 245 0084 DF92      		push r13
 246               	.LCFI0:
 247               		.cfi_def_cfa_offset 3
 248               		.cfi_offset 13, -2
 249 0086 EF92      		push r14
 250               	.LCFI1:
 251               		.cfi_def_cfa_offset 4
 252               		.cfi_offset 14, -3
 253 0088 FF92      		push r15
 254               	.LCFI2:
 255               		.cfi_def_cfa_offset 5
 256               		.cfi_offset 15, -4
 257 008a 0F93      		push r16
 258               	.LCFI3:
 259               		.cfi_def_cfa_offset 6
 260               		.cfi_offset 16, -5
 261 008c 1F93      		push r17
 262               	.LCFI4:
 263               		.cfi_def_cfa_offset 7
 264               		.cfi_offset 17, -6
 265 008e CF93      		push r28
 266               	.LCFI5:
 267               		.cfi_def_cfa_offset 8
 268               		.cfi_offset 28, -7
 269 0090 DF93      		push r29
 270               	.LCFI6:
 271               		.cfi_def_cfa_offset 9
 272               		.cfi_offset 29, -8
 273 0092 00D0      		rcall .
 274 0094 00D0      		rcall .
 275 0096 00D0      		rcall .
 276 0098 0F92      		push __tmp_reg__
 277               	.LCFI7:
 278               		.cfi_def_cfa_offset 16
 279 009a CDB7      		in r28,__SP_L__
 280 009c DEB7      		in r29,__SP_H__
 281               	.LCFI8:
 282               		.cfi_def_cfa_register 28
 283               	/* prologue: function */
 284               	/* frame size = 7 */
 285               	/* stack size = 14 */
 286               	.L__stack_usage = 14
 287 009e 182F      		mov r17,r24
  53:grn_sht21.c   **** 	uint16_t messwert;
 288               		.loc 1 53 2 is_stmt 1 view .LVU76
  53:grn_sht21.c   **** 	uint16_t messwert;
 289               		.loc 1 53 10 is_stmt 0 view .LVU77
 290 00a0 1A82      		std Y+2,__zero_reg__
 291 00a2 1982      		std Y+1,__zero_reg__
 292 00a4 1B82      		std Y+3,__zero_reg__
  54:grn_sht21.c   **** 	float rueckgabewert;
 293               		.loc 1 54 2 is_stmt 1 view .LVU78
  55:grn_sht21.c   **** 	
 294               		.loc 1 55 2 view .LVU79
  57:grn_sht21.c   **** 	rueckgabewert=0;
 295               		.loc 1 57 2 view .LVU80
 296               	.LVL25:
  58:grn_sht21.c   **** 
 297               		.loc 1 58 2 view .LVU81
  61:grn_sht21.c   **** 	if(TWIGetStatus() != 0x08)return 4; //kontrolle ob erfolgreich sonst Abbruch mit Error Code
 298               		.loc 1 61 2 view .LVU82
 299 00a6 0E94 0000 		call TWIStart
 300               	.LVL26:
  62:grn_sht21.c   **** 	TWIWrite(SHT21_W);					//Adresse und Schreiben
 301               		.loc 1 62 2 view .LVU83
  62:grn_sht21.c   **** 	TWIWrite(SHT21_W);					//Adresse und Schreiben
 302               		.loc 1 62 5 is_stmt 0 view .LVU84
 303 00aa 0E94 0000 		call TWIGetStatus
 304               	.LVL27:
  62:grn_sht21.c   **** 	TWIWrite(SHT21_W);					//Adresse und Schreiben
 305               		.loc 1 62 4 view .LVU85
 306 00ae 8830      		cpi r24,lo8(8)
 307 00b0 01F0      		breq .L43
  62:grn_sht21.c   **** 	TWIWrite(SHT21_W);					//Adresse und Schreiben
 308               		.loc 1 62 35 view .LVU86
 309 00b2 E12C      		mov r14,__zero_reg__
 310 00b4 F12C      		mov r15,__zero_reg__
 311 00b6 00E8      		ldi r16,lo8(-128)
 312 00b8 10E4      		ldi r17,lo8(64)
 313               	.LVL28:
 314               	.L23:
  99:grn_sht21.c   **** 
 315               		.loc 1 99 1 view .LVU87
 316 00ba EC82      		std Y+4,r14
 317 00bc FD82      		std Y+5,r15
 318 00be 0E83      		std Y+6,r16
 319 00c0 1F83      		std Y+7,r17
 320 00c2 6C81      		ldd r22,Y+4
 321 00c4 7D81      		ldd r23,Y+5
 322 00c6 8E81      		ldd r24,Y+6
 323 00c8 9F81      		ldd r25,Y+7
 324               	/* epilogue start */
 325 00ca 2796      		adiw r28,7
 326 00cc 0FB6      		in __tmp_reg__,__SREG__
 327 00ce F894      		cli
 328 00d0 DEBF      		out __SP_H__,r29
 329 00d2 0FBE      		out __SREG__,__tmp_reg__
 330 00d4 CDBF      		out __SP_L__,r28
 331 00d6 DF91      		pop r29
 332 00d8 CF91      		pop r28
 333 00da 1F91      		pop r17
 334 00dc 0F91      		pop r16
 335 00de FF90      		pop r15
 336 00e0 EF90      		pop r14
 337 00e2 DF90      		pop r13
 338 00e4 0895      		ret
 339               	.LVL29:
 340               	.L43:
  63:grn_sht21.c   **** 	if(TWIGetStatus() != 0x18)return 5;	//kontrolle ob erfolgreich sonst Abbruch mit Error Code
 341               		.loc 1 63 2 is_stmt 1 view .LVU88
 342 00e6 80E8      		ldi r24,lo8(-128)
 343 00e8 0E94 0000 		call TWIWrite
 344               	.LVL30:
  64:grn_sht21.c   **** 	switch(measure_mode)
 345               		.loc 1 64 2 view .LVU89
  64:grn_sht21.c   **** 	switch(measure_mode)
 346               		.loc 1 64 5 is_stmt 0 view .LVU90
 347 00ec 0E94 0000 		call TWIGetStatus
 348               	.LVL31:
  64:grn_sht21.c   **** 	switch(measure_mode)
 349               		.loc 1 64 4 view .LVU91
 350 00f0 8831      		cpi r24,lo8(24)
 351 00f2 01F4      		brne .L35
  65:grn_sht21.c   **** 	{
 352               		.loc 1 65 2 is_stmt 1 view .LVU92
 353 00f4 1123      		tst r17
 354 00f6 01F0      		breq .L25
 355 00f8 1130      		cpi r17,lo8(1)
 356 00fa 01F4      		brne .L27
  68:grn_sht21.c   **** 	}
 357               		.loc 1 68 17 view .LVU93
 358 00fc 83EF      		ldi r24,lo8(-13)
 359 00fe 0E94 0000 		call TWIWrite
 360               	.LVL32:
  68:grn_sht21.c   **** 	}
 361               		.loc 1 68 48 view .LVU94
 362               	.L27:
  70:grn_sht21.c   **** 
 363               		.loc 1 70 2 view .LVU95
  70:grn_sht21.c   **** 
 364               		.loc 1 70 5 is_stmt 0 view .LVU96
 365 0102 0E94 0000 		call TWIGetStatus
 366               	.LVL33:
  70:grn_sht21.c   **** 
 367               		.loc 1 70 4 view .LVU97
 368 0106 8832      		cpi r24,lo8(40)
 369 0108 01F4      		brne .L36
  72:grn_sht21.c   **** 	while(!(PINC &= ~(1<<PC5)));		//wait to end conversion (Master hold mode)
 370               		.loc 1 72 2 is_stmt 1 view .LVU98
  72:grn_sht21.c   **** 	while(!(PINC &= ~(1<<PC5)));		//wait to end conversion (Master hold mode)
 371               		.loc 1 72 7 is_stmt 0 view .LVU99
 372 010a 3D98      		cbi 0x7,5
  73:grn_sht21.c   **** 	DDRC |= (1<<PC5);					//set SCL as Output
 373               		.loc 1 73 2 is_stmt 1 view .LVU100
 374               	.L28:
  73:grn_sht21.c   **** 	DDRC |= (1<<PC5);					//set SCL as Output
 375               		.loc 1 73 29 discriminator 1 view .LVU101
  73:grn_sht21.c   **** 	DDRC |= (1<<PC5);					//set SCL as Output
 376               		.loc 1 73 7 discriminator 1 view .LVU102
  73:grn_sht21.c   **** 	DDRC |= (1<<PC5);					//set SCL as Output
 377               		.loc 1 73 15 is_stmt 0 discriminator 1 view .LVU103
 378 010c 96B1      		in r25,0x6
 379 010e 9F7D      		andi r25,lo8(-33)
 380 0110 96B9      		out 0x6,r25
  73:grn_sht21.c   **** 	DDRC |= (1<<PC5);					//set SCL as Output
 381               		.loc 1 73 7 discriminator 1 view .LVU104
 382 0112 9923      		tst r25
 383 0114 01F0      		breq .L28
  74:grn_sht21.c   **** 
 384               		.loc 1 74 2 is_stmt 1 view .LVU105
  74:grn_sht21.c   **** 
 385               		.loc 1 74 7 is_stmt 0 view .LVU106
 386 0116 3D9A      		sbi 0x7,5
  76:grn_sht21.c   **** 	if(TWIGetStatus() != 0x10)return 7; //kontrolle ob erfolgreich sonst Abbruch mit Error Code
 387               		.loc 1 76 2 is_stmt 1 view .LVU107
 388 0118 0E94 0000 		call TWIStart
 389               	.LVL34:
  77:grn_sht21.c   **** 	TWIWrite(SHT21_R);					//Adresse und lesen
 390               		.loc 1 77 2 view .LVU108
  77:grn_sht21.c   **** 	TWIWrite(SHT21_R);					//Adresse und lesen
 391               		.loc 1 77 5 is_stmt 0 view .LVU109
 392 011c 0E94 0000 		call TWIGetStatus
 393               	.LVL35:
  77:grn_sht21.c   **** 	TWIWrite(SHT21_R);					//Adresse und lesen
 394               		.loc 1 77 4 view .LVU110
 395 0120 8031      		cpi r24,lo8(16)
 396 0122 01F0      		breq .L44
  77:grn_sht21.c   **** 	TWIWrite(SHT21_R);					//Adresse und lesen
 397               		.loc 1 77 35 view .LVU111
 398 0124 E12C      		mov r14,__zero_reg__
 399 0126 F12C      		mov r15,__zero_reg__
 400 0128 00EE      		ldi r16,lo8(-32)
 401 012a 10E4      		ldi r17,lo8(64)
 402               	.LVL36:
  77:grn_sht21.c   **** 	TWIWrite(SHT21_R);					//Adresse und lesen
 403               		.loc 1 77 35 view .LVU112
 404 012c 00C0      		rjmp .L23
 405               	.LVL37:
 406               	.L35:
  64:grn_sht21.c   **** 	switch(measure_mode)
 407               		.loc 1 64 35 view .LVU113
 408 012e E12C      		mov r14,__zero_reg__
 409 0130 F12C      		mov r15,__zero_reg__
 410 0132 00EA      		ldi r16,lo8(-96)
 411 0134 10E4      		ldi r17,lo8(64)
 412               	.LVL38:
  64:grn_sht21.c   **** 	switch(measure_mode)
 413               		.loc 1 64 35 view .LVU114
 414 0136 00C0      		rjmp .L23
 415               	.LVL39:
 416               	.L36:
  70:grn_sht21.c   **** 
 417               		.loc 1 70 35 view .LVU115
 418 0138 E12C      		mov r14,__zero_reg__
 419 013a F12C      		mov r15,__zero_reg__
 420 013c 00EC      		ldi r16,lo8(-64)
 421 013e 10E4      		ldi r17,lo8(64)
 422               	.LVL40:
  70:grn_sht21.c   **** 
 423               		.loc 1 70 35 view .LVU116
 424 0140 00C0      		rjmp .L23
 425               	.LVL41:
 426               	.L25:
  67:grn_sht21.c   **** 		case RH_HOLD:	TWIWrite(SHT21_HUM_HOLDMASTER);break;	//Modus = Temperatur master hold = on
 427               		.loc 1 67 16 is_stmt 1 view .LVU117
 428 0142 83EE      		ldi r24,lo8(-29)
 429 0144 0E94 0000 		call TWIWrite
 430               	.LVL42:
  67:grn_sht21.c   **** 		case RH_HOLD:	TWIWrite(SHT21_HUM_HOLDMASTER);break;	//Modus = Temperatur master hold = on
 431               		.loc 1 67 48 view .LVU118
  67:grn_sht21.c   **** 		case RH_HOLD:	TWIWrite(SHT21_HUM_HOLDMASTER);break;	//Modus = Temperatur master hold = on
 432               		.loc 1 67 3 is_stmt 0 view .LVU119
 433 0148 00C0      		rjmp .L27
 434               	.L44:
  78:grn_sht21.c   **** 	if(TWIGetStatus() != 0x40)return 8;	//kontrolle ob erfolgreich sonst Abbruch mit Error Code
 435               		.loc 1 78 2 is_stmt 1 view .LVU120
 436 014a 81E8      		ldi r24,lo8(-127)
 437 014c 0E94 0000 		call TWIWrite
 438               	.LVL43:
  79:grn_sht21.c   **** 	raw[0] = TWIReadACK();				//empfange MSB
 439               		.loc 1 79 2 view .LVU121
  79:grn_sht21.c   **** 	raw[0] = TWIReadACK();				//empfange MSB
 440               		.loc 1 79 5 is_stmt 0 view .LVU122
 441 0150 0E94 0000 		call TWIGetStatus
 442               	.LVL44:
  79:grn_sht21.c   **** 	raw[0] = TWIReadACK();				//empfange MSB
 443               		.loc 1 79 4 view .LVU123
 444 0154 8034      		cpi r24,lo8(64)
 445 0156 01F0      		breq .L45
  79:grn_sht21.c   **** 	raw[0] = TWIReadACK();				//empfange MSB
 446               		.loc 1 79 35 view .LVU124
 447 0158 E12C      		mov r14,__zero_reg__
 448 015a F12C      		mov r15,__zero_reg__
 449 015c 00E0      		ldi r16,0
 450 015e 11E4      		ldi r17,lo8(65)
 451               	.LVL45:
  79:grn_sht21.c   **** 	raw[0] = TWIReadACK();				//empfange MSB
 452               		.loc 1 79 35 view .LVU125
 453 0160 00C0      		rjmp .L23
 454               	.LVL46:
 455               	.L45:
  80:grn_sht21.c   **** 	if(TWIGetStatus() != 0x50)return 9;	//kontrolle ob erfolgreich sonst Abbruch mit Error Code
 456               		.loc 1 80 2 is_stmt 1 view .LVU126
  80:grn_sht21.c   **** 	if(TWIGetStatus() != 0x50)return 9;	//kontrolle ob erfolgreich sonst Abbruch mit Error Code
 457               		.loc 1 80 11 is_stmt 0 view .LVU127
 458 0162 0E94 0000 		call TWIReadACK
 459               	.LVL47:
 460 0166 082F      		mov r16,r24
  80:grn_sht21.c   **** 	if(TWIGetStatus() != 0x50)return 9;	//kontrolle ob erfolgreich sonst Abbruch mit Error Code
 461               		.loc 1 80 9 view .LVU128
 462 0168 8983      		std Y+1,r24
  81:grn_sht21.c   **** 	raw[1] = TWIReadACK();				//empfange LSB / durch NACK wird checksumme nicht empfangen
 463               		.loc 1 81 2 is_stmt 1 view .LVU129
  81:grn_sht21.c   **** 	raw[1] = TWIReadACK();				//empfange LSB / durch NACK wird checksumme nicht empfangen
 464               		.loc 1 81 5 is_stmt 0 view .LVU130
 465 016a 0E94 0000 		call TWIGetStatus
 466               	.LVL48:
  81:grn_sht21.c   **** 	raw[1] = TWIReadACK();				//empfange LSB / durch NACK wird checksumme nicht empfangen
 467               		.loc 1 81 4 view .LVU131
 468 016e 8035      		cpi r24,lo8(80)
 469 0170 01F0      		breq .L29
 470               	.L30:
  81:grn_sht21.c   **** 	raw[1] = TWIReadACK();				//empfange LSB / durch NACK wird checksumme nicht empfangen
 471               		.loc 1 81 35 view .LVU132
 472 0172 E12C      		mov r14,__zero_reg__
 473 0174 F12C      		mov r15,__zero_reg__
 474 0176 00E1      		ldi r16,lo8(16)
 475 0178 11E4      		ldi r17,lo8(65)
 476               	.LVL49:
  81:grn_sht21.c   **** 	raw[1] = TWIReadACK();				//empfange LSB / durch NACK wird checksumme nicht empfangen
 477               		.loc 1 81 35 view .LVU133
 478 017a 00C0      		rjmp .L23
 479               	.LVL50:
 480               	.L29:
  82:grn_sht21.c   **** 	if(TWIGetStatus() != 0x50)return 9;	//kontrolle ob erfolgreich sonst Abbruch mit Error Code
 481               		.loc 1 82 2 is_stmt 1 view .LVU134
  82:grn_sht21.c   **** 	if(TWIGetStatus() != 0x50)return 9;	//kontrolle ob erfolgreich sonst Abbruch mit Error Code
 482               		.loc 1 82 11 is_stmt 0 view .LVU135
 483 017c 0E94 0000 		call TWIReadACK
 484               	.LVL51:
 485 0180 F82E      		mov r15,r24
  82:grn_sht21.c   **** 	if(TWIGetStatus() != 0x50)return 9;	//kontrolle ob erfolgreich sonst Abbruch mit Error Code
 486               		.loc 1 82 9 view .LVU136
 487 0182 8A83      		std Y+2,r24
  83:grn_sht21.c   **** 	raw[2] = TWIReadNACK();				//receive checksum
 488               		.loc 1 83 2 is_stmt 1 view .LVU137
  83:grn_sht21.c   **** 	raw[2] = TWIReadNACK();				//receive checksum
 489               		.loc 1 83 5 is_stmt 0 view .LVU138
 490 0184 0E94 0000 		call TWIGetStatus
 491               	.LVL52:
  83:grn_sht21.c   **** 	raw[2] = TWIReadNACK();				//receive checksum
 492               		.loc 1 83 4 view .LVU139
 493 0188 8035      		cpi r24,lo8(80)
 494 018a 01F4      		brne .L30
  84:grn_sht21.c   **** 	TWIStop();							//close TWI
 495               		.loc 1 84 2 is_stmt 1 view .LVU140
  84:grn_sht21.c   **** 	TWIStop();							//close TWI
 496               		.loc 1 84 11 is_stmt 0 view .LVU141
 497 018c 0E94 0000 		call TWIReadNACK
 498               	.LVL53:
 499 0190 D82E      		mov r13,r24
  84:grn_sht21.c   **** 	TWIStop();							//close TWI
 500               		.loc 1 84 9 view .LVU142
 501 0192 8B83      		std Y+3,r24
  85:grn_sht21.c   **** 	
 502               		.loc 1 85 2 is_stmt 1 view .LVU143
 503 0194 0E94 0000 		call TWIStop
 504               	.LVL54:
  87:grn_sht21.c   **** 	messwert &= ~0x003;								//Loescht letzte 2 Bits (Status Bits)
 505               		.loc 1 87 2 view .LVU144
  87:grn_sht21.c   **** 	messwert &= ~0x003;								//Loescht letzte 2 Bits (Status Bits)
 506               		.loc 1 87 22 is_stmt 0 view .LVU145
 507 0198 902F      		mov r25,r16
 508 019a 8F2D      		mov r24,r15
 509               	.LVL55:
  88:grn_sht21.c   **** 	switch(measure_mode)
 510               		.loc 1 88 2 is_stmt 1 view .LVU146
  88:grn_sht21.c   **** 	switch(measure_mode)
 511               		.loc 1 88 11 is_stmt 0 view .LVU147
 512 019c 8C7F      		andi r24,252
 513               	.LVL56:
  89:grn_sht21.c   **** 	{
 514               		.loc 1 89 2 is_stmt 1 view .LVU148
 515 019e 1123      		tst r17
 516 01a0 01F4      		brne .+2
 517 01a2 00C0      		rjmp .L31
 518 01a4 1130      		cpi r17,lo8(1)
 519 01a6 01F4      		brne .L46
  92:grn_sht21.c   **** 	}
 520               		.loc 1 92 17 view .LVU149
  92:grn_sht21.c   **** 	}
 521               		.loc 1 92 55 is_stmt 0 view .LVU150
 522 01a8 9C01      		movw r18,r24
 523 01aa 50E0      		ldi r21,0
 524 01ac 40E0      		ldi r20,0
 525 01ae 2C83      		std Y+4,r18
 526 01b0 3D83      		std Y+5,r19
 527 01b2 4E83      		std Y+6,r20
 528 01b4 5F83      		std Y+7,r21
 529 01b6 CA01      		movw r24,r20
 530               	.LVL57:
  92:grn_sht21.c   **** 	}
 531               		.loc 1 92 55 view .LVU151
 532 01b8 B901      		movw r22,r18
 533 01ba 0E94 0000 		call __floatunsisf
 534               	.LVL58:
  92:grn_sht21.c   **** 	}
 535               		.loc 1 92 55 view .LVU152
 536 01be E62F      		mov r30,r22
  92:grn_sht21.c   **** 	}
 537               		.loc 1 92 53 view .LVU153
 538 01c0 20E0      		ldi r18,0
 539 01c2 30E0      		ldi r19,0
 540 01c4 4AEF      		ldi r20,lo8(-6)
 541 01c6 5AE3      		ldi r21,lo8(58)
 542 01c8 EC83      		std Y+4,r30
 543 01ca 7D83      		std Y+5,r23
 544 01cc 8E83      		std Y+6,r24
 545 01ce 9F83      		std Y+7,r25
 546 01d0 6C81      		ldd r22,Y+4
 547 01d2 7D81      		ldd r23,Y+5
 548 01d4 8E81      		ldd r24,Y+6
 549 01d6 9F81      		ldd r25,Y+7
 550 01d8 0E94 0000 		call __mulsf3
 551               	.LVL59:
 552 01dc E62F      		mov r30,r22
 553 01de 682F      		mov r22,r24
 554 01e0 892F      		mov r24,r25
  92:grn_sht21.c   **** 	}
 555               		.loc 1 92 31 view .LVU154
 556 01e2 20E0      		ldi r18,0
 557 01e4 30E0      		ldi r19,0
 558 01e6 40EC      		ldi r20,lo8(-64)
 559 01e8 50E4      		ldi r21,lo8(64)
 560               	.L42:
 561 01ea EC83      		std Y+4,r30
 562 01ec 7D83      		std Y+5,r23
 563 01ee 6E83      		std Y+6,r22
 564 01f0 8F83      		std Y+7,r24
 565 01f2 6C81      		ldd r22,Y+4
 566 01f4 7D81      		ldd r23,Y+5
 567 01f6 8E81      		ldd r24,Y+6
 568 01f8 9F81      		ldd r25,Y+7
 569 01fa 0E94 0000 		call __subsf3
 570               	.LVL60:
 571 01fe 7B01      		movw r14,r22
 572 0200 8C01      		movw r16,r24
 573               	.LVL61:
  92:grn_sht21.c   **** 	}
 574               		.loc 1 92 72 is_stmt 1 view .LVU155
 575               	.L33:
  95:grn_sht21.c   **** 	{
 576               		.loc 1 95 2 view .LVU156
  95:grn_sht21.c   **** 	{
 577               		.loc 1 95 5 is_stmt 0 view .LVU157
 578 0202 4D2D      		mov r20,r13
 579 0204 62E0      		ldi r22,lo8(2)
 580 0206 CE01      		movw r24,r28
 581 0208 0196      		adiw r24,1
 582 020a 0E94 0000 		call sht21_checksum
 583               	.LVL62:
  95:grn_sht21.c   **** 	{
 584               		.loc 1 95 4 view .LVU158
 585 020e 8823      		tst r24
 586 0210 01F4      		brne .+2
 587 0212 00C0      		rjmp .L23
  97:grn_sht21.c   **** 	}else return rueckgabewert;	
 588               		.loc 1 97 10 view .LVU159
 589 0214 E12C      		mov r14,__zero_reg__
 590               	.LVL63:
  97:grn_sht21.c   **** 	}else return rueckgabewert;	
 591               		.loc 1 97 10 view .LVU160
 592 0216 F12C      		mov r15,__zero_reg__
 593 0218 00E8      		ldi r16,lo8(-128)
 594 021a 1FE3      		ldi r17,lo8(63)
 595 021c 00C0      		rjmp .L23
 596               	.LVL64:
 597               	.L46:
  89:grn_sht21.c   **** 	{
 598               		.loc 1 89 2 view .LVU161
 599 021e E12C      		mov r14,__zero_reg__
 600 0220 F12C      		mov r15,__zero_reg__
 601 0222 00E0      		ldi r16,0
 602 0224 10E0      		ldi r17,0
 603               	.LVL65:
  89:grn_sht21.c   **** 	{
 604               		.loc 1 89 2 view .LVU162
 605 0226 00C0      		rjmp .L33
 606               	.LVL66:
 607               	.L31:
  91:grn_sht21.c   **** 		case RH_HOLD:	rueckgabewert = (-6.0 + 125.0/65536 * (float)messwert);break; // return relative hu
 608               		.loc 1 91 16 is_stmt 1 view .LVU163
  91:grn_sht21.c   **** 		case RH_HOLD:	rueckgabewert = (-6.0 + 125.0/65536 * (float)messwert);break; // return relative hu
 609               		.loc 1 91 57 is_stmt 0 view .LVU164
 610 0228 9C01      		movw r18,r24
 611 022a 50E0      		ldi r21,0
 612 022c 40E0      		ldi r20,0
 613 022e 2C83      		std Y+4,r18
 614 0230 3D83      		std Y+5,r19
 615 0232 4E83      		std Y+6,r20
 616 0234 5F83      		std Y+7,r21
 617 0236 CA01      		movw r24,r20
 618               	.LVL67:
  91:grn_sht21.c   **** 		case RH_HOLD:	rueckgabewert = (-6.0 + 125.0/65536 * (float)messwert);break; // return relative hu
 619               		.loc 1 91 57 view .LVU165
 620 0238 B901      		movw r22,r18
 621 023a 0E94 0000 		call __floatunsisf
 622               	.LVL68:
  91:grn_sht21.c   **** 		case RH_HOLD:	rueckgabewert = (-6.0 + 125.0/65536 * (float)messwert);break; // return relative hu
 623               		.loc 1 91 57 view .LVU166
 624 023e E62F      		mov r30,r22
  91:grn_sht21.c   **** 		case RH_HOLD:	rueckgabewert = (-6.0 + 125.0/65536 * (float)messwert);break; // return relative hu
 625               		.loc 1 91 55 view .LVU167
 626 0240 22E5      		ldi r18,lo8(82)
 627 0242 38EB      		ldi r19,lo8(-72)
 628 0244 4FE2      		ldi r20,lo8(47)
 629 0246 5BE3      		ldi r21,lo8(59)
 630 0248 EC83      		std Y+4,r30
 631 024a 7D83      		std Y+5,r23
 632 024c 8E83      		std Y+6,r24
 633 024e 9F83      		std Y+7,r25
 634 0250 6C81      		ldd r22,Y+4
 635 0252 7D81      		ldd r23,Y+5
 636 0254 8E81      		ldd r24,Y+6
 637 0256 9F81      		ldd r25,Y+7
 638 0258 0E94 0000 		call __mulsf3
 639               	.LVL69:
 640 025c E62F      		mov r30,r22
 641 025e 682F      		mov r22,r24
 642 0260 892F      		mov r24,r25
  91:grn_sht21.c   **** 		case RH_HOLD:	rueckgabewert = (-6.0 + 125.0/65536 * (float)messwert);break; // return relative hu
 643               		.loc 1 91 30 view .LVU168
 644 0262 26E6      		ldi r18,lo8(102)
 645 0264 36E6      		ldi r19,lo8(102)
 646 0266 4BE3      		ldi r20,lo8(59)
 647 0268 52E4      		ldi r21,lo8(66)
 648 026a 00C0      		rjmp .L42
 649               		.cfi_endproc
 650               	.LFE8:
 652               	.Letext0:
 653               		.file 4 "/usr/avr/include/stdint.h"
 654               		.file 5 "grn_TWI.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 grn_sht21.c
     /tmp/ccKe37ub.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccKe37ub.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccKe37ub.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccKe37ub.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccKe37ub.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccKe37ub.s:12     .text:0000000000000000 sht21_init
     /tmp/ccKe37ub.s:122    .text:0000000000000044 sht21_checksum
     /tmp/ccKe37ub.s:239    .text:0000000000000084 sht21_measure

UNDEFINED SYMBOLS
TWIStart
TWIGetStatus
TWIWrite
TWIStop
__floatunsisf
__mulsf3
__subsf3
TWIReadACK
TWIReadNACK
